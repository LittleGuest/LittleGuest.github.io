{"categories":[{"title":"Docker","uri":"https://littleguest.github.io/categories/docker/"},{"title":"Git","uri":"https://littleguest.github.io/categories/git/"},{"title":"Java","uri":"https://littleguest.github.io/categories/java/"},{"title":"Linux","uri":"https://littleguest.github.io/categories/linux/"},{"title":"MySQL","uri":"https://littleguest.github.io/categories/mysql/"},{"title":"Rust","uri":"https://littleguest.github.io/categories/rust/"},{"title":"Vim","uri":"https://littleguest.github.io/categories/vim/"},{"title":"嵌入式","uri":"https://littleguest.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"title":"开源协议","uri":"https://littleguest.github.io/categories/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/"},{"title":"开源项目","uri":"https://littleguest.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"},{"title":"数据结构及算法","uri":"https://littleguest.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95/"},{"title":"树莓派","uri":"https://littleguest.github.io/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"计算机","uri":"https://littleguest.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"posts":[{"content":"树莓派时钟 用 Max7219 做了一个时钟。效果如下：\nGitHub\n运行需要指定 Max7219 data、cs、clk对应树莓派引脚编号，如\n./raspi_clock 24 23 18  ","id":0,"section":"posts","summary":"树莓派时钟 用 Max7219 做了一个时钟。效果如下： GitHub 运行需要指定 Max7219 data、cs、clk对应树莓派引脚编号，如 ./raspi_clock 24 23 18","tags":["max7219"],"title":"树莓派时钟","uri":"https://littleguest.github.io/posts/raspi_clock/","year":"2021"},{"content":"怎么来的 笔者使用 Hugo 搭建的博客，最近发现一款主题（pure），还蛮不错的。但是需要将主题里面的yaml格式转换为toml的格式（为什么要转换呢？大概是因为Rust的配置文件格式也是toml的吧。😜），配置文件里面大概有两百多行（😳）吧，但是呢，笔者又特别懒，不想一行一行的翻译成toml的格式。所以我去GitHub上搜了一下，一搜就有很多好的开源项目。唉，我就不用，就是要自己写（😏）。\n想要的功能  json、toml、yaml这三种格式互相转换（暂时这三种）。 支持web、命令行和桌面应用。  实现 这里笔者打算使用 Rust 开发，项目名称就叫cffc（Configuration file format conversion）吧。\n话不多说，直接开搞（😋）。\n通过几天零碎的时间，初步实现了json，yaml和toml这三种文件格式之间的转换。\n最近整了点新活。之前Flutter2.0不是支持桌面应用了嘛（🤙🤙🤙），所以我想用Flutter来写UI，Rust来负责转换。\n解决跨语言调用  方式一：将用到的函数做成服务，通过网络协议或者进程间通信； 方式二：通过FFI调用，将Rust编译为动态链接库；  我这里采用第二种方式，Flutter通过FFI调用Rust函数。\nRust库 项目地址\ncffc应用 项目地址\n","id":1,"section":"posts","summary":"怎么来的 笔者使用 Hugo 搭建的博客，最近发现一款主题（pure），还蛮不错的。但是需要将主题里面的yaml格式转换为toml的格式（为什么要转换呢","tags":["配置文件格式转换"],"title":"配置文件格式转换","uri":"https://littleguest.github.io/posts/cffc/","year":"2021"},{"content":"什么是二进制 二进制是计算机内部运算中采用的进制，在这样的进制系统下，只有0，1两个数字，计算机内部的所有运算（包括位运算）都是在二进制的基础上进行的。\n位运算分类 基本的位运算分为6种，分别为按位与、按位或、按位异或、按位取反，左移和右移。\n   运算 运算符 解释     按位与 \u0026amp; 两个对应位都为1时，结果才为1，否则为0   按位或 ` `   按位异或 ^ 两个对应位相同为0，不同为1   按位取反 ~ 0变1，1变0   左移 \u0026lt;\u0026lt; 各二进位全部左移若干位，高位丢弃，低位补0   右移 \u0026gt;\u0026gt; 各二进位全部右移若干位，对无符号数，高位补0，有符号数，使用最高位的数补齐    什么是原码、反码和补码及其计算方式 原码、反码和补码都是计算机中有符号数的表示方法，都由符号位和数值位组成。符号位用0表示正数，1表示负数。\n原码 最高位表示符号位，其它位存放该数的二进制的绝对值。\n0表示正数，1表示负数。用来区分正负数。\n   十进制表示 8位二进制表示     +10 0000 1010   -10 1000 1010   5 0000 0101   -5 1000 0101    如果将两个数相加，结果如下：\n0000 1010 1000 1010 --------- 1001 0100 --\u0026gt; 10+(-10) = -20 0000 1010 1000 0101 --------- 1000 1111 --\u0026gt; 10+5 = 15 0000 1010 0000 1010 --------- 0001 0100 --\u0026gt; 10+10 = 20 1000 1010 1000 1010 --------- 1001 0100 --\u0026gt; (-10)+(-10) = -20 1000 1010 1000 0101 --------- 1000 1111 --\u0026gt; (-10)+(-5) = -15  将结果转为十进制，明显正负数相加结果是不正确的。这是由于符号位导致的。\n为了解决一个数的正负相加不等于零这个问题，引入了 反码。\n反码 正数的反码等于原码，负数的反码是它的原码除符号位外，其余位按位取反。\n    原码 反码     +10 0000 1010 0000 1010   -10 1000 1010 1111 0101   -5 1000 0101 1111 1010    0000 1010 1111 0101 --------- 1111 1111 --\u0026gt; 10+(-10) = -0 1111 0101 1111 1010 ------------------- 1110 1111 --\u0026gt; (-10)+(-5) = -16  虽然解决了一个数的正负相加不等于零这个问题，但是引入了新的问题，两个负数相加的结果不正确\n补码 计算方式：正数和0的补码等于原码，负数的补码是其反码加一。\n    原码 补码     +10 0000 1010 0000 1010   -10 1000 1010 1111 0110   -5 1000 0101 1111 1011    1111 0110 1111 1011 --------- 1111 0001 --\u0026gt; (-10)+(-5) = -15 0000 1010 1111 1011 --------- 0000 0101 --\u0026gt; 10+(-5) = 5 # 模：表示n位的计算机计量范围是`0-2^n-1`，模为`2^n` # 这里用的是8位，所以模为 2^8=256 # 10-5=10+256-5=261 ==\u0026gt; 1 0000 0101 ==\u0026gt; 0000 0101 ==\u0026gt; 5  补充：已知原码算补码或已知补码算原码，都是取反后加一。\n举个栗子： # 按位与 # 10 \u0026amp; 5 = 0 0000 1010 \u0026amp; 0000 0101 --------- 0000 0000 # 按位或 # 10 | 5 = 15 0000 1010 | 0000 0101 --------- 0000 1111 # 按位异或 # 10 ^ 5 = 15 0000 1010 ^ 0000 0101 --------- 0000 1111 # 按位取反：~x=-(x+1) # ~10 = 11 ~ 0000 1010 --\u0026gt; 10的补码 ----------- 1111 0101 --\u0026gt; 按位取反 ----------- 1000 1011 --\u0026gt; 得到原码 # ~(-5) = 4 ~ 1111 1011 --\u0026gt; -5的补码 ----------- 0000 0100 --\u0026gt; 按位取反 ----------- 0000 0100 --\u0026gt; 得到原码 # 左移：x \u0026lt;\u0026lt; n = x * 2^n（2的n次幂） # 10 \u0026lt;\u0026lt; 3 = 80 0000 1010 \u0026lt;\u0026lt; 3 --------- 0101 0000 # -10 \u0026lt;\u0026lt; 3 = -80 1000 1010 \u0026lt;\u0026lt; 3 --------- 1101 0000 # 右移 # 10 \u0026gt;\u0026gt; 3 = 1 0000 1010 \u0026gt;\u0026gt; 3 --------- 0000 0001 # -10 \u0026gt;\u0026gt; 3 = -2 1111 0110 --\u0026gt; -10的补码 \u0026gt;\u0026gt; 3 --------- 1111 1110 --\u0026gt; 右移三位 --------- 1000 0010 --\u0026gt; 原码  应用场景 1、判断奇偶 println!(\u0026quot;{}\u0026quot;, 11 \u0026amp; 1 == 1); // true println!(\u0026quot;{}\u0026quot;, 18 \u0026amp; 1 == 0); // true  2、交换两个数 let mut a = 10; let mut b = 5; a = a ^ b; b = a ^ b; // b = (a ^ b) ^ b = a ^ (b ^ b) = a ^ 0 = a a = a ^ b; // a = (a ^ b) ^ a = (a ^ a) ^ b = 0 ^ b = b println!(\u0026quot;a = {}, b = {}\u0026quot;, a, b); // a = 5, b = 10 // 两个相同的数异或的结果为0，一个数和0的异或结果是这个数本身。  3、找出没有重复的数 给出一个整型数组，[0,5,8,9,5,8,0]，其中有一个数只出现了一次，其他的数都出现了两次，找出出现一次的数。\nlet arr = [0, 5, 8, 9, 5, 8, 0]; let mut temp = arr[0]; let mut i = 1; while i \u0026lt; arr.len() { temp ^= arr[i]; i += 1; } println!(\u0026quot;{}\u0026quot;, temp); // 9 // 0 ^ 5 ^ 8 ^ 9 ^ 5 ^ 8 ^ 0 = (0 ^0) ^ (5 ^ 5) ^ (8 ^ 8) ^ 9 = 0 ^ 0 ^ 0 ^ 9 = 9  4、加密 5、其他 ","id":2,"section":"posts","summary":"什么是二进制 二进制是计算机内部运算中采用的进制，在这样的进制系统下，只有0，1两个数字，计算机内部的所有运算（包括位运算）都是在二进制的基础","tags":["位运算"],"title":"位运算","uri":"https://littleguest.github.io/posts/bit-operation/","year":"2021"},{"content":"简介  雪花算法（Snowflake）是一种生成分布式全局唯一ID的算法，生成的ID称为 Snowflake IDs 或 snowflakes。\n 这种算法由 Twitter 创建，并用于推文的ID。\n组成 一个 Snowflake ID 有64bit，\n 1 位表示正负：0表示正数，1表示负数 41 位表示时间戳，总共可以表示69年（(2^41-1)/(1000 * 60 * 60 * 24 * 365)） 10 位表示工作机器ID，其中，高位5bit表示dataCenterId，低位5bit表示workerId 12 位表示序列号，记录同一毫秒内产生的不同ID  实现 Rust /// 雪花算法 use std::sync::atomic::{AtomicI64, Ordering}; struct Snowflake { // 开始时间戳 epoch: i64, // 数据中心ID datacenter_id: i64, // 工作机器ID worker_id: i64, // 序列号 sequence: AtomicI64, // 上次产生ID的时间戳 last_timestamp: AtomicI64, } impl Default for Snowflake { fn default() -\u0026gt; Self { Self { epoch: 1618710339362, datacenter_id: 0, worker_id: 0, sequence: AtomicI64::new(0), last_timestamp: AtomicI64::new(-1), } } } impl Snowflake { fn new(datacenter_id: i64, worker_id: i64) -\u0026gt; Self { Self { epoch: 1618710339362, datacenter_id, worker_id, sequence: AtomicI64::new(0), last_timestamp: AtomicI64::new(-1), } } fn next_id(\u0026amp;self) -\u0026gt; i64 { // 获取当前时间戳 let mut timestamp = self.time_gen(); let last_timestamp = self.last_timestamp.fetch_or(0, Ordering::Relaxed); let sequence = self.sequence.fetch_or(0, Ordering::Relaxed); // 判断当前时间戳是否小于上次产生ID的时间戳 if timestamp \u0026lt; last_timestamp { panic!(\u0026quot;时间后退，拒绝产生ID\u0026quot;); } // 判断当前时间戳是否等于上次产生ID的时间戳 if timestamp == last_timestamp { let sequence = (sequence + 1) \u0026amp; -1 ^ (-1 \u0026lt;\u0026lt; 12); self.sequence.swap(sequence, Ordering::Relaxed); // 判断序列号是否溢出 if sequence == 0 { timestamp = self.til_next_millis(); } } else { self.sequence.swap(0, Ordering::Relaxed); } self.last_timestamp.swap(timestamp, Ordering::Relaxed); ((timestamp - self.epoch) \u0026lt;\u0026lt; 22) | (self.datacenter_id \u0026lt;\u0026lt; 17) | (self.worker_id \u0026lt;\u0026lt; 12) | self.sequence.fetch_or(0, Ordering::Relaxed) } // 获取当前毫秒时间戳 fn time_gen(\u0026amp;self) -\u0026gt; i64 { chrono::Local::now().timestamp_millis() } // 阻塞获取下一毫秒时间戳 fn til_next_millis(\u0026amp;self) -\u0026gt; i64 { let mut timestamp = self.time_gen(); let last_timestamp = self.last_timestamp.fetch_or(0, Ordering::Relaxed); while timestamp \u0026lt; last_timestamp { timestamp = self.time_gen(); } timestamp } } fn main() { let snowflake = Snowflake::default(); for _ in 1..=100 { println!(\u0026quot;{:?}\u0026quot;, snowflake.next_id()); } }  Java import cn.hutool.core.date.SystemClock; public class Snowflake { private final long epoch = 1618710339362L; private final long workerId; private final long datacenterId; private long sequence = 0L; private long lastTimestamp = -1L; public Snowflake() { this.datacenterId = 0; this.workerId = 0; } public Snowflake(long workerId, long datacenterId) { this.workerId = workerId; this.datacenterId = datacenterId; } /** * 获取下一个 ID * * @return 下一个 ID */ public synchronized long nextId() { long timestamp = timeGen(); if (timestamp \u0026lt; lastTimestamp) { throw new RuntimeException(\u0026quot;时间后退，拒绝产生ID\u0026quot;); } if (lastTimestamp == timestamp) { // 相同毫秒内，序列号自增 sequence = (sequence + 1) \u0026amp; -1 ^ (-1 \u0026lt;\u0026lt; 12); if (sequence == 0) { // 同一毫秒的序列数已经达到最大 timestamp = tilNextMillis(lastTimestamp); } } else { sequence = 0L; } lastTimestamp = timestamp; // 时间戳部分 | 数据中心部分 | 机器标识部分 | 序列号部分 return ((timestamp - epoch) \u0026lt;\u0026lt; 22) | (workerId \u0026lt;\u0026lt; 17) | (datacenterId \u0026lt;\u0026lt; 12) | sequence; } protected long tilNextMillis(long lastTimestamp) { long timestamp = timeGen(); while (timestamp \u0026lt;= lastTimestamp) { timestamp = timeGen(); } return timestamp; } protected long timeGen() { return SystemClock.now(); } public static void main(String[] args) { Snowflake snowflake = new Snowflake(); for (int i = 1; i \u0026lt;= 100; i++) { System.out.println(snowflake.nextId()); } } }  雪花算法的优缺点 优点\n 能满足高并发分布式系统环境下ID不重复 生成效率高 基于时间戳，可以保证基本有序递增 不依赖于第三方的库或者中间件 生成的id具有时序性和唯一性  缺点\n 依赖机器的时间  ","id":3,"section":"posts","summary":"简介 雪花算法（Snowflake）是一种生成分布式全局唯一ID的算法，生成的ID称为 Snowflake IDs 或 snowflakes。 这种算法由 Twitter 创建，并用于推文","tags":["算法"],"title":"雪花算法（Snowflake）","uri":"https://littleguest.github.io/posts/snowflake/","year":"2021"},{"content":"在这里我们使用 Gogs 来搭建私有 Git 服务。\n$ docker pull gogs/gogs $ docker docker run -d --name=gogs -p 12200:22 -p 13000:3000 -v /var/gogs:/data gogs/gogs  首次访问 localhost:13000 会出现安装界面，\n我们这里数据库选择 MySQL ，并创建对应的 gogs 账户和 gogs 库。对应的 HTTP端口 和 SSH端口 设置为映射到主机的端口。然后创建一个管理员的账号。配置如下：\n但是这会遇到问题，错误为数据库连接不上，因为我的 MySQL 也是使用 Docker 安装的。数据库主机地址不管是用 localhost:3306 还是 127.0.0.1:3306 都不起作用。这是因为这两个容器不在同一个网络中，所以首先得创建一个网络，指定 MySQL 和 Gogs 的容器在同一个网络中。\n# 创建网络 $ docker network create gogs-mysql8 # 创建 MySQL 容器，指定网络 $ docker run -d --name gogs-mysql8 --network gogs-mysql8 -p 13001:3306 -e MYSQL_ROOT_PASSWORD=root mysql:latest # 创建 Gogs容器，指定网络 $ docker run -d --name=gogs --network gogs-mysql8 -p 12200:22 -p 13000:3000 -v /var/gogs:/data gogs/gogs  重新配置数据库连接\n登录之后，创建一个仓库 gogs-demo , clone 到本地，添加或修改 README.md 文件，再次提交，可以看到成功了。\n","id":4,"section":"posts","summary":"在这里我们使用 Gogs 来搭建私有 Git 服务。 $ docker pull gogs/gogs $ docker docker run -d --name=gogs -p 12200:22 -p 13000:3000 -v /var/gogs:/data gogs/gogs 首次访问 localhost:13000 会出现安装界面， 我们这里数据库选择 MySQL ，并创建对应的 gogs 账户和 gogs 库","tags":["Docker","Git"],"title":"Docker 搭建私有 Git 服务","uri":"https://littleguest.github.io/posts/docker-gogs/","year":"2021"},{"content":"怎样选择开源协议\n在网上找了一张远古对比图，大家可以简单了解下\n作为个人开发者，我一般选择的是 MIT License 。\n","id":5,"section":"posts","summary":"怎样选择开源协议 在网上找了一张远古对比图，大家可以简单了解下 作为个人开发者，我一般选择的是 MIT License 。","tags":["开源协议"],"title":"开源协议对比","uri":"https://littleguest.github.io/posts/open-source-license/","year":"2021"},{"content":"Cargo 是 Rust 的包管理工具\n cargo new xxx --bin 创建一个 binary crate cargo build 编译 crate cargo run 编译和运行 binary crate  Cargo 目录 . ├── Cargo.lock ├── Cargo.toml ├── benches │ └── large-input.rs ├── examples │ └── simple.rs ├── src │ ├── bin │ │ └── another_executable.rs │ ├── lib.rs │ └── main.rs └── tests └── some-integration-tests.rs  ##　Cargo.toml\n cargo-features — 不稳定，nightly版本的功能 [package] — 定义一个包  name — 包名（必需的）  软件包名称是用于引用软件包的标识符。当它被列为另一个软件包的依赖关系时，以及作为推断的lib和bin目标的默认名称时，都会使用它。 **包名必须只使用字母数字字符或-或_，不能为空**。需要注意的是， cargo new 和 cargo init 对包名施加了一些额外的限制，比如强制要求包名是有效的 Rust 标识符，而不是关键字。 crates.io 对包名施加了更多的限制，比如强制要求只能使用 ASCII 字符，不能使用保留的名称，不能使用特殊的 Windows 名称，比如 \u0026ldquo;nul\u0026rdquo;，不能太长，等等。   version — 包版本（必需的） authors — 包的作者 edition — Rust 版本 description — 包描述 documentation — 包文档地址 URL readme — 包的 README 文件路径  readme字段应该是软件包根目录下的文件路径（相对于这个Cargo.toml），它包含了软件包的一般信息。crates.io会将其解释为Markdown，并将其呈现在crate的页面上。 如果没有为这个字段指定值，而根目录下存在名为 README.md、README.txt 或 README 的文件，那么将使用该文件的名称。您可以通过将此字段设置为false 来抑制这种行为。如果该字段被设置为 true，则会使用README.md的默认值。   homepage — 包的主页地址 URL repository — 包源码仓库地址 URL license — 包许可证 license-file — 许可证文本路径 keywords — 包关键字 categories — 包的分类 workspace — 包工作空间路径 build — 包构建脚本的路径 links — 包中链接的本地库的名称 exclude — 发布时要排除的文件 include — 发布时要包含的文件 publish — 可以用来防止发布包 metadata — 额外的外部工具设置 default-run — 通过 cargo run 运行默认二进制文件 autobins — 禁用自动发现 bins autoexamples — 禁用自动发现 example autotests — 禁用自动发现 test autobenches — 禁用自动发现 bench   Target 列表  [lib] — Library target settings. [[bin]] — Binary target settings. [[example]] — Example target settings. [[test]] — Test target settings. [[bench]] — Benchmark target settings.   依赖列表：  [dependencies] — 包的依赖 [dev-dependencies] — examples、tests 和 benchmarks的依赖 [build-dependencies] — 构建脚本的依赖 [target] — 平台特有的依赖   [badges] — 注册显示的徽章(Badges to display on a registry.) [features] — 条件编译某些功能(Conditional compilation features.) [patch] — 覆盖依赖 [replace] — 覆盖依赖（已废弃） [profile] — 编译器设置和优化 [workspace] — 工作空间定义  ","id":6,"section":"posts","summary":"Cargo 是 Rust 的包管理工具 cargo new xxx --bin 创建一个 binary crate cargo build 编译 crate cargo run 编译和运行 binary crate Cargo 目录 . ├── Cargo.lock ├── Cargo.toml ├── benches │ └── large-input.rs ├── examples │ └── simple.rs ├── src │ ├─","tags":["Cargo"],"title":"Rust 的包管理工具 Cargo","uri":"https://littleguest.github.io/posts/rust-cargo/","year":"2021"},{"content":"Vim 杂记 vim 模式  普通模式：vim 启动后的默认模式,移动光标，删除文本等等都在该模式下 插入模式 在普通模式下，按 a 或 i 进入该模式 可视模式 在普通模式下，按 v 或 Ctrl + v 进入 选择模式 命令行模式 在普通模式下，按 : 进入该模式； Ex模式  以下 n 代表数字，表示重复操作\n光标移动  向下移动：j、nj 向上移动：k、nk 向左移动：h、nh 向右移动：l、nl 以单词移动：  向前 w、nw、W，光标停在单词词首 向后 b、nb、B，光标停在单词词首 向前 e、ne、E，光标停在单词词尾 向后 ge、nge，光标停在单词词尾   移动光标到行尾：$ 、n$ 移动光标到行首：0（数字）、^（行首非空字符） 移动到第几行：nG、G（移动到最后一行）或命令行模式输入:n 向前翻页（向下）：Ctrl + f 向后翻页（向上）：Ctrl + b \u0026hellip;  进入插入模式    命令 说明     i 在当前光标处进行编辑   I 在行首插入   A 在行末插入   a 在光标后插入编辑   o 在当前行后插入一个新行   O 在当前行前插入一个新行   cw 替换从光标所在位置后到一个单词结尾的字符    退出 Vim  命令行模式退出    命令 说明     :q! 强制退出，不保存   :q 退出   :wq! 强制保存并退出   :w \u0026lt;文件路径\u0026gt; 另存为   :saveas 文件路径 另存为   :x 保存并退出   :wq 保存并退出     普通模式退出 shift + z + z  查找 在普通模式下\n /想要搜索的内容  支持正则表达式 默认是大小写不敏感的 搜索大小写敏感的  在想要搜索的内容后加 \\C 开启智能推测 :set smartcase 输入大写的，匹配大写的，反之亦然     ?：与 / 相反 *：搜索光标当前所在的单词 #：与 * 相反  输入 n 或 N 向下或向上搜索\n替换 在普通模式下\n 替换单个字符：r、nr 替换多个字符（一个一个替换）：R、nR 批量替换：:%s/源字符串/目的字符串/g  复制  y：组合命令 x  粘贴 p、np粘贴文本缓冲区的内容\n删除文本  d：组合命令  d、y、x 共用一个文本缓冲区，也可以将三个命令看做是复制、剪切操作\n撤销和恢复撤销  撤销：u 恢复撤销：Ctrl + r  ","id":7,"section":"posts","summary":"Vim 杂记 vim 模式 普通模式：vim 启动后的默认模式,移动光标，删除文本等等都在该模式下 插入模式 在普通模式下，按 a 或 i 进入该模式 可视模式 在普通模式下","tags":["Vim"],"title":"Vim 杂记","uri":"https://littleguest.github.io/posts/vim-notes/","year":"2021"},{"content":"因为笔者本身没有学过任何有关硬件的知识，所以理解上可能会出现偏差。在实际的操作过程中也显得比较吃力。\n准备相关物品   树莓派 4B ：（买来吃灰很久了的，一直没有用上，现在终于有机肥了）   一个 三色RGB LED 模块   4根母对母杜邦线（这玩意儿还分公母，公母的区别就是一个是针，一个是孔。🤭🤭）   然后呢，我面对这几样东西的时候一脸懵逼，完全不知道接下来该怎么做，也不知道怎么把这几样东西连接起来。\n先莫慌，在实际操作之前，我们还需要了解几个东东。\n简单了解相关知识   引脚\n 引脚，又叫管脚，英文叫Pin。就是从集成电路（芯片）内部电路引出与外围电路的接线，所有的引脚就构成了这块芯片的接口。引线末端的一段，通过软钎焊使这一段与印制板上的焊盘共同形成焊点。引脚可划分为脚跟（bottom）、脚趾（toe）、脚侧（side）等部分。\n   GPIO\n GPIO（英语：General-purpose input/output），通用型之输入输出的简称，功能类似8051的P0—P3，其接脚可以供使用者由程控自由使用，PIN脚依现实考量可作为通用输入（GPI）或通用输出（GPO）或通用输入与输出（GPIO），如当clk generator, chip select等。 既然一个引脚可以用于输入、输出或其他特殊功能，那么一定有寄存器用来选择这些功能。对于输入，一定可以通过读取某个寄存器来确定引脚电位的高低；对于输出，一定可以通过写入某个寄存器来让这个引脚输出高电位或者低电位；对于其他特殊功能，则有另外的寄存器来控制它们。\n   SPI\n SPI是串行外设接口（Serial Peripheral Interface）的缩写。SPI，是一种高速的，全双工，同步的通信总线，并且在芯片的管脚上只占用四根线。\n   树莓派 4B 引脚分布图   RGB\n RGB色彩模式是工业界的一种颜色标准，是通过对红(R)、绿(G)、蓝(B)三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，RGB即是代表红、绿、蓝三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是运用最广的颜色系统之一。\n R、G、B各个范围是[0,255]\n  LED ：发光二极管。\n  接线    rgb-led灯 树莓派     R 18（GPIO） 或 12（物理引脚）   G 15（GPIO） 或 10（物理引脚）   B 14（GPIO） 或 8（物理引脚）   GND Ground 或 6（物理引脚）    如下图：\nVSCode 远程连接 树莓派 笔者这里选择使用 VSCode 的扩展 Remote - SSH 连接到 树莓派，直接在树莓派上开发。\n树莓派开启 SPI $ sudo raspi-config  编码 笔者这里使用的是 rppal 这个 crate。\nuse rppal::gpio::OutputPin; use std::error::Error; use rppal::gpio::Gpio; use std::thread; use std::time::Duration; /// BCM /// rgbled灯引脚对应树莓派引脚 const R: u8 = 18; const G: u8 = 15; const B: u8 = 14; struct RGBLed { red_pin: OutputPin, green_pin: OutputPin, blue_pin: OutputPin, } fn main() -\u0026gt; Result\u0026lt;(), Box\u0026lt;dyn Error\u0026gt;\u0026gt; { let g = Gpio::new()?; let red_pin = g.get(R)?.into_output(); let green_pin = g.get(G)?.into_output(); let blue_pin = g.get(B)?.into_output(); let mut rgb_led = RGBLed { red_pin, green_pin, blue_pin, }; loop { // 设置高电频 rgb_led.red_pin.set_high(); // 睡200ms thread::sleep(Duration::from_millis(200)); // 设置低电频 rgb_led.red_pin.set_low(); rgb_led.green_pin.set_high(); thread::sleep(Duration::from_millis(200)); rgb_led.green_pin.set_low(); rgb_led.blue_pin.set_high(); thread::sleep(Duration::from_millis(200)); rgb_led.blue_pin.set_low(); } }  效果如下：\n 虽然过程艰难，还有很多东西不懂，但是还是点亮了 RGB-LED 灯。哇，很激动，有木有，有木有。😜😜\n以上内容如有错误，请指正。\n参考地址:\nhttps://zhuanlan.zhihu.com/p/74035695\n","id":8,"section":"posts","summary":"因为笔者本身没有学过任何有关硬件的知识，所以理解上可能会出现偏差。在实际的操作过程中也显得比较吃力。 准备相关物品 树莓派 4B ：（买来吃灰很久了的","tags":["Rust嵌入式","树莓派-RGBLED"],"title":"Rust 控制 三色RGB LED灯","uri":"https://littleguest.github.io/posts/raspberrypi-rgbled-rust/","year":"2021"},{"content":"如何将可执行二进制文件打包成AppImage文件？   下载构建工具 linuxdeploy\n  # 创建 AppDir 目录 $ linuxdeploy.AppImage --appdir T2048.AppDir  生成的目录结构如下    将可执行文件放在 T2048.AppDir/usr/bin/ 目录下 将桌面快捷方式放在 T2048.AppDir/usr/share/applications/ 目录下，随便找个已有的桌面快捷方式复制过来，文件后缀名为 .desktop，内容如下  [Desktop Entry] Name=T2048 Exec=t-2048 Terminal=false Type=Application Icon=t-2048 Categories=Game;   将图标放在 T2048.AppDir/usr/share/icons/hicolor/128x128/apps/ 目录下，大小选择对应的目录即可    # 将 AppDir 目录打包成 .AppImage 文件 $ linuxdeploy.AppImage --appdir T2048.AppDir/ --output appimage  AppDir 目录变化\n  到此，打包结束。\n当然这里是最简单的方式，还有很多其他的配置。然这些就已经满足我当前的需求了，如果以后有时间，再做深入研究吧。\n","id":9,"section":"posts","summary":"如何将可执行二进制文件打包成AppImage文件？ 下载构建工具 linuxdeploy # 创建 AppDir 目录 $ linuxdeploy.AppImage --appdir T2048.AppDir 生成的目录结构如下 将可执行文件放在 T2048.AppDir/usr/bin/ 目录下 将桌面快捷方式","tags":["Linux","AppImage"],"title":"AppImage打包二进制文件","uri":"https://littleguest.github.io/posts/appimage/","year":"2021"},{"content":"本机系统为 Linux\n查看Rust支持的系统和架构\n参考 https://wiki.archlinux.org/index.php/Rust\n$ rustup target list # 或者 $ rustc --print target-list  Windows   aarch64-pc-windows-msvc\n  i586-pc-windows-msvc\n  i686-pc-windows-gnu\n  i686-pc-windows-msvc\n  x86_64-pc-windows-gnu\n   $ rustup toolchain install stable-x86_64-pc-windows-gnu $ sudo apt install mingw-w64    # vim ~/.cargo/config [target.x86_64-pc-windows-gnu] linker = \u0026quot;/usr/bin/x86_64-w64-mingw32-gcc\u0026quot; ar = \u0026quot;/usr/bin/x86_64-w64-mingw32-ar\u0026quot;    $ cargo build --release --target x86_64-pc-windows-gnu    x86_64-pc-windows-msvc\n  Linux Mac ","id":10,"section":"posts","summary":"本机系统为 Linux 查看Rust支持的系统和架构 参考 https://wiki.archlinux.org/index.php/Rust $ rustup target list # 或者 $ rustc --print target-list Windows aarch64-pc-windows-msvc i586-pc-windows-msvc i686-pc-windows-gnu i686-pc-windows-msvc x86_64-pc-windows-gnu $ rustup toolchain install stable-x86_64-pc-windows-gnu $ sudo apt install mingw-w64 # vim ~/.cargo/config [target.x86_64-pc-windows-gnu] linker = \u0026quot;/usr/bin/x86_64-w64-mingw32-gcc\u0026quot; ar = \u0026quot;/usr/bin/x86_64-w64-mingw32-ar\u0026quot; $ cargo build --release --target x86_64-pc-windows-gnu x86_64-pc-windows-msvc Linux Mac","tags":["Rust","交叉编译"],"title":"Rust交叉编译","uri":"https://littleguest.github.io/posts/rust-cross-compiling/","year":"2021"},{"content":"使用 Rust 实现 2048 闲来无事，想着用 Rust 做一个练手的项目，碰巧，之前玩过2048，玩法比较简单，感觉还蛮有意思的。那我就在想我能不能用 Rust 实现呢？\n所以这个项目就诞生了。\n项目地址\n首先来说玩法，玩家只需控制方向键移动数字方块，合并数字获得最高分就行了。其次，如果要用代码来实现的话，也不是很复杂。按我的思路来说，可以将整个看作是一个二维数组，其次不管是向上，向下，向左，向右移动数字方块，我们都可以将它看作是向左移动。\n举个栗子，现在有这样一个东东，我们尝试着先向左向右移动，\n[0, 0, 0, 2] [4, 2, 0, 2] [0, 2, 2, 0] [0, 0, 0, 0]  如果我们向左移动，将会得到这个\n[2, 0, 0, 0] [4, 4, 0, 0] [4, 0, 0, 0] [0, 0, 0, 0]  如果我们向右移动，将会得到这个\n[0, 0, 0, 2] [0, 0, 4, 4] [0, 0, 0, 4] [0, 0, 0, 0]  其实我们可以将向右移动看作是向左移动之后的翻转。接下来康康向上和向下移动，\n向上移动，得到如下结果：\n[4, 4, 2, 4] [0, 0, 0, 0] [0, 0, 0, 0] [0, 0, 0, 0]  而向下移动，得到的是：\n[0, 0, 0, 0] [0, 0, 0, 0] [0, 0, 0, 0] [4, 4, 2, 4]  我们同样可以将向下移动看作是向上移动之后的翻转。\n来来来，让我们仔细看看向上移动的过程。可以看作是下面\n[0, 0, 0, 2] [0, 4, 0, 0] [4, 0, 0, 0] [4, 4, 2, 4] [4, 2, 0, 2] --\u0026gt; [0, 2, 2, 0] --\u0026gt; [4, 0, 0, 0] --\u0026gt; [0, 0, 0, 0] [0, 2, 2, 0] --\u0026gt; [0, 0, 2, 0] --\u0026gt; [2, 0, 0, 0] --\u0026gt; [0, 0, 0, 0] [0, 0, 0, 0] [2, 2, 0, 0] [4, 0, 0, 0] [0, 0, 0, 0]   将二维数组进行 矩阵转置 操作 向左合并 再次将二维数组进行矩阵转置 操作  所以我们可以将向上，向下，向左，向右移动看作是同一个操作。\n接下来看核心代码，其中 PALACE_SIZE 的值为 4\n/// 向左合并数字 fn merge(vs: \u0026amp;[u128]) -\u0026gt; Vec\u0026lt;u128\u0026gt; { let mut q = vs.iter().collect::\u0026lt;VecDeque\u0026lt;_\u0026gt;\u0026gt;(); // 存放合并之后的值的队列 let mut cvq = VecDeque::new(); // 是否合并过 let mut merged = false; while !q.is_empty() { let qv = q.pop_front().unwrap(); if *qv != 0 { if let Some(cv) = cvq.back() { if *cv == *qv \u0026amp;\u0026amp; !merged { cvq.pop_back(); cvq.push_back(*qv * 2); merged = true; } else { cvq.push_back(*qv); merged = false; } } else { cvq.push_back(*qv); merged = false; } } } // 将剩余的补0 if cvq.len() \u0026lt; PALACE_SIZE { (0..PALACE_SIZE - cvq.len()).for_each(|_| { cvq.push_back(0); }); } cvq.into_iter().collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;() } /// 移动 pub fn move_palaces(palaces: \u0026amp;mut Vec\u0026lt;Vec\u0026lt;u128\u0026gt;\u0026gt;, me: MoveDirection) { match me { // 向上移动 MoveDirection::Up =\u0026gt; { for x in 0..PALACE_SIZE { let mut o = Vec::new(); for y in 0..PALACE_SIZE { o.push(palaces[y][x]); } merge(\u0026amp;o) .iter() .enumerate() .for_each(|(y, yv)| { palaces[y][x] = *yv; }); } } // 向下移动 MoveDirection::Down =\u0026gt; { for x in 0..PALACE_SIZE { let mut o = Vec::new(); for y in 0..PALACE_SIZE { o.push(palaces[PALACE_SIZE - y - 1][x]); } merge(\u0026amp;o.into_iter().collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;()) .iter() .enumerate() .for_each(|(y, yv)| { palaces[PALACE_SIZE - y - 1][x] = *yv; }); } } // 向左移动 MoveDirection::Left =\u0026gt; { (0..PALACE_SIZE).for_each(|i| { palaces[i] = merge(\u0026amp;palaces[i]); }); } // 向右移动 MoveDirection::Right =\u0026gt; { (0..PALACE_SIZE).for_each(|i| { palaces[i] = merge( \u0026amp;palaces[i].iter().rev().cloned().collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;(), ) .iter() .rev() .cloned() .collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;(); }); } } // 在空位置生成数字方块 empty_position_gen(palaces); }  这些就是该游戏的核心了。\n","id":11,"section":"posts","summary":"使用 Rust 实现 2048 闲来无事，想着用 Rust 做一个练手的项目，碰巧，之前玩过2048，玩法比较简单，感觉还蛮有意思的。那我就在想我能不能用 Rust 实现呢？ 所以这","tags":["游戏"],"title":"一款可以在终端玩的2048小游戏","uri":"https://littleguest.github.io/posts/t-2048/","year":"2021"},{"content":"MySQL 主从复制 下载 MySQL 镜像\n官方镜像的 MySQL 版本是8.x\n$ docker pull mysql  创建 MySQL 主从容器\n主\n$ docker run -d --name mysql-master -p 13306:3306 -e MYSQL_ROOT_PASSWORD=root mysql  从\n$ docker run -d --name mysql-slave -p 13307:3306 -e MYSQL_ROOT_PASSWORD=root mysql  分别用工具连接，测试能正常使用。\n配置\n  主库配置\n# 进入主库容器 $ docker exec -it mysql-master bash # 编辑MySQL配置 $ vim /etc/mysql/my.cnf  添加如下内容\n[mysqld] server-id = 1 log-bin = mysql-bin  # 退出容器并重启容器 $ docker restart mysql-master  再次进入容器，在主库中创建数据同步用户 slave ，授予改用户 REPLICATION SLAVE 和 REPLICATION CLIENT 权限，用户在主从库之间同步数据。\nmysql\u0026gt; CREATE USER 'slave'@'%' IDENTIFIED BY 'slave'; mysql\u0026gt; GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'slave'@'%';    从库配置\n在同样的配置文件中添加如下配置\n[mysqld] server-id = 2 log-bin = mysql-slave-bin relay_log = mysql-slave-relay-bin    开启主从配置\n在主客户端输入\nmysql\u0026gt; show master status; +------------------+----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+------------------+-------------------+ | mysql-bin.000001 | 713 | | | | +------------------+----------+--------------+------------------+-------------------+ 1 row in set (0.00 sec)  在从客户端输入\nmysql\u0026gt; change master to master_host='172.17.0.2', master_user='slave', master_password='slave', master_port=3306, master_log_file='mysql-bin.000001', master_log_pos=713, master_connect_retry=30;  命令说明\n master_host ：Master的地址，指的是容器的独立ip,可以通过 docker inspect --format='{{.NetworkSettings.IPAddress}}' 容器名称|容器id 查询容器的ip master_port：Master的端口号，指的是容器的端口号 master_user：用于数据同步的用户 master_password：用于同步的用户的密码 master_log_file：指定 Slave 从哪个日志文件开始复制数据，即上文中提到的 File 字段的值 master_log_pos：从哪个 Position 开始读，即上文中提到的 Position 字段的值 master_connect_retry：如果连接失败，重试的时间间隔，单位是秒，默认是60秒  # 查看主从同步状态 mysql\u0026gt; show slave status \\G; *************************** 1. row *************************** Slave_IO_State: Master_Host: 172.17.0.2 Master_User: slave Master_Port: 3306 Connect_Retry: 30 Master_Log_File: mysql-bin.000001 Read_Master_Log_Pos: 713 Relay_Log_File: emysql-slave-relay-bin.000001 Relay_Log_Pos: 4 Relay_Master_Log_File: mysql-bin.000001 Slave_IO_Running: No Slave_SQL_Running: No Replicate_Do_DB: Replicate_Ignore_DB: Replicate_Do_Table: Replicate_Ignore_Table: Replicate_Wild_Do_Table: Replicate_Wild_Ignore_Table: Last_Errno: 0 Last_Error: Skip_Counter: 0 Exec_Master_Log_Pos: 713 Relay_Log_Space: 156 Until_Condition: None Until_Log_File: Until_Log_Pos: 0 Master_SSL_Allowed: No Master_SSL_CA_File: Master_SSL_CA_Path: Master_SSL_Cert: Master_SSL_Cipher: Master_SSL_Key: Seconds_Behind_Master: NULL Master_SSL_Verify_Server_Cert: No Last_IO_Errno: 0 Last_IO_Error: Last_SQL_Errno: 0 Last_SQL_Error: Replicate_Ignore_Server_Ids: Master_Server_Id: 0 Master_UUID: Master_Info_File: mysql.slave_master_info SQL_Delay: 0 SQL_Remaining_Delay: NULL Slave_SQL_Running_State: Master_Retry_Count: 86400 Master_Bind: Last_IO_Error_Timestamp: Last_SQL_Error_Timestamp: Master_SSL_Crl: Master_SSL_Crlpath: Retrieved_Gtid_Set: Executed_Gtid_Set: Auto_Position: 0 Replicate_Rewrite_DB: Channel_Name: Master_TLS_Version: Master_public_key_path: Get_master_public_key: 0 Network_Namespace: 1 row in set, 1 warning (0.01 sec) ERROR: No query specified  # 开启主从复制 mysql\u0026gt; start slave;  # 再次查看状态 mysql\u0026gt; show slave status \\G; *************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 172.17.0.2 Master_User: slave Master_Port: 3306 Connect_Retry: 30 Master_Log_File: mysql-bin.000001 Read_Master_Log_Pos: 1581 Relay_Log_File: emysql-slave-relay-bin.000002 Relay_Log_Pos: 1192 Relay_Master_Log_File: mysql-bin.000001 Slave_IO_Running: Yes Slave_SQL_Running: Yes Replicate_Do_DB: Replicate_Ignore_DB: Replicate_Do_Table: Replicate_Ignore_Table: Replicate_Wild_Do_Table: Replicate_Wild_Ignore_Table: Last_Errno: 0 Last_Error: Skip_Counter: 0 Exec_Master_Log_Pos: 1581 Relay_Log_Space: 1408 Until_Condition: None Until_Log_File: Until_Log_Pos: 0 Master_SSL_Allowed: No Master_SSL_CA_File: Master_SSL_CA_Path: Master_SSL_Cert: Master_SSL_Cipher: Master_SSL_Key: Seconds_Behind_Master: 0 Master_SSL_Verify_Server_Cert: No Last_IO_Errno: 0 Last_IO_Error: Last_SQL_Errno: 0 Last_SQL_Error: Replicate_Ignore_Server_Ids: Master_Server_Id: 1 Master_UUID: a9da6629-75d6-11eb-96b3-0242ac110002 Master_Info_File: mysql.slave_master_info SQL_Delay: 0 SQL_Remaining_Delay: NULL Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates Master_Retry_Count: 86400 Master_Bind: Last_IO_Error_Timestamp: Last_SQL_Error_Timestamp: Master_SSL_Crl: Master_SSL_Crlpath: Retrieved_Gtid_Set: Executed_Gtid_Set: Auto_Position: 0 Replicate_Rewrite_DB: Channel_Name: Master_TLS_Version: Master_public_key_path: Get_master_public_key: 0 Network_Namespace: 1 row in set, 1 warning (0.01 sec) ERROR: No query specified  正常情况下，开启主从复制后 Slave_IO_Running 和 Slave_SQL_Running 都是 Yes。\n  测试\n在主库中\n# 创建库 mysql\u0026gt; create database msr_test; # 在 msr_test 库中创建表 mysql\u0026gt; CREATE TABLE `sys_dict` ( `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'ID', `name` varchar(255) NOT NULL COMMENT '字典名称', `description` varchar(255) DEFAULT NULL COMMENT '描述', `create_by` varchar(255) DEFAULT NULL COMMENT '创建者', `update_by` varchar(255) DEFAULT NULL COMMENT '更新者', `create_time` datetime DEFAULT NULL COMMENT '创建日期', `update_time` datetime DEFAULT NULL COMMENT '更新时间', PRIMARY KEY (`id`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT COMMENT='数据字典'; # 在表中插入数据 mysql\u0026gt; INSERT INTO msr_test.sys_dict (name,description,create_by,update_by,create_time,update_time) VALUES ('user_status','用户状态',NULL,NULL,'2019-10-27 20:31:36.0',NULL), ('dept_status','部门状态',NULL,NULL,'2019-10-27 20:31:36.0',NULL), ('job_status','岗位状态',NULL,NULL,'2019-10-27 20:31:36.0',NULL);  在从库中\n# 查看库 mysql\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | msr_test | | mysql | | performance_schema | | sys | +--------------------+ # 查看表数据 mysql\u0026gt; select * from msr_test.sys_dict; +----+-------------+-------------+-----------+-----------+---------------------+-------------+ | id | name | description | create_by | update_by | create_time | update_time | +----+-------------+-------------+-----------+-----------+---------------------+-------------+ | 15 | user_status | | NULL | NULL | 2019-10-27 20:31:36 | NULL | | 16 | dept_status | | NULL | NULL | 2019-10-27 20:31:36 | NULL | | 17 | job_status | | NULL | NULL | 2019-10-27 20:31:36 | NULL | +----+-------------+-------------+-----------+-----------+---------------------+-------------+  说明MySQL主从复制是部署成功了的。\n最后\n因为容器每次启动的时候ip会变化，所以都会给个固定的ip\n# 查看docker占用的网段 $ ifconfig br-ab794da606af: flags=4099\u0026lt;UP,BROADCAST,MULTICAST\u0026gt; mtu 1500 inet 172.18.0.1 netmask 255.255.0.0 broadcast 172.18.255.255 ether 02:42:35:06:cc:a4 txqueuelen 0 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 docker0: flags=4099\u0026lt;UP,BROADCAST,MULTICAST\u0026gt; mtu 1500 inet 172.17.0.1 netmask 255.255.0.0 broadcast 172.17.255.255 ether 02:42:b4:c0:2d:85 txqueuelen 0 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0  # 创建自定义网络 $ docker network create --subnet 172.19.0.0/24 mysql-master-slave  # 创建容器时指定ip $ docker run -d --name mysql-master-n --network mysql-master-slave --ip 172.19.0.2 -p 13306:3306 -e MYSQL_ROOT_PASSWORD=root mysql $ docker run -d --name mysql-slave-n --network mysql-master-slave --ip 172.19.0.3 -p 13307:3306 -e MYSQL_ROOT_PASSWORD=root mysql  参考 https://juejin.cn/post/6907112721532059662\n","id":12,"section":"posts","summary":"MySQL 主从复制 下载 MySQL 镜像 官方镜像的 MySQL 版本是8.x $ docker pull mysql 创建 MySQL 主从容器 主 $ docker run -d --name mysql-master -p 13306:3306 -e MYSQL_ROOT_PASSWORD=root mysql 从 $ docker run -d --name mysql-slave -p 13307:3306 -e MYSQL_ROOT_PASSWORD=root mysql 分别用工具连接，测试能正常","tags":["Docker","MySQL主从"],"title":"使用Docker部署主从MySQL","uri":"https://littleguest.github.io/posts/docker-mysql-master-slave/","year":"2021"},{"content":"如何使用Docker搭建MySQL服务 下载 MySQL 镜像\n官方镜像的 MySQL 版本是8.x\n$ docker pull mysql  启动容器\n -d 在后台运行 \u0026ndash;name mysql 指定容器的名字为 mysql -p 映射容器ip:3306到主机ip:13306 -e MYSQL_ROOT_PASSWORD=root 初始化root用户密码为root  $ docker run -d --name mysql -p 13306:3306 -e MYSQL_ROOT_PASSWORD=root mysql  如果要将数据保存在主机上，这需要加上下面的参数\n -v 将容器中的文件挂载到主机  $ docker run -d --name mysql -p 13306:3306 -e MYSQL_ROOT_PASSWORD=root -v /home/mysql/cnf.d:/etc/my.cnf.d -v /home/mysql/data:/var/lib/mysql/data mysql  进入容器\n$ docker exec -it mysql bash  进入 MySQL\n$ mysql -u root -p  输入密码，能正常进入，就说明已经搭建好了。\n连接 MySQL\n这里注意使用 Navicat15 连接时，主机地址为 localhost 时，会出现如下错误：\n2002 - Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock' (2 \u0026quot;没有那个文件或目录\u0026quot;)  解决方案之一 将 localhost 换成 127.0.0.1\n而我使用 DBeaver 连接时，则没有出现这种情况。\n","id":13,"section":"posts","summary":"如何使用Docker搭建MySQL服务 下载 MySQL 镜像 官方镜像的 MySQL 版本是8.x $ docker pull mysql 启动容器 -d 在后台运行 \u0026ndash;name mysql 指定容器的名字为 mysql -p 映射容器ip:3","tags":["Docker","MySQL"],"title":"Docker搭建MySQL","uri":"https://littleguest.github.io/posts/docker-mysql/","year":"2021"},{"content":"首先，先在这里抛出 两个问题\n1. 如何将一个 List 转换为一个 HashMap\n2. 如何将两个 List 转换为一个 HashMap\n让我们来看看 在 Java 中是如何实现的。😄\n第一个问题\n@Data @AllArgsConstructor public class Person { private Long id; private String name; private String sex; public static void main(String[] args) { List\u0026lt;Person\u0026gt; persons = new ArrayList\u0026lt;\u0026gt;(); persons.add(new Person(1L, \u0026quot;张三\u0026quot;, \u0026quot;男\u0026quot;)); persons.add(new Person(2L, \u0026quot;李四\u0026quot;, \u0026quot;男\u0026quot;)); persons.add(new Person(3L, \u0026quot;王兰\u0026quot;, \u0026quot;女\u0026quot;)); // 根据性别进行分组 Map\u0026lt;String, List\u0026lt;Person\u0026gt;\u0026gt; sexMap = persons.stream().collect(Collectors.groupingBy(Person::getSex)); System.out.println(sexMap); // {女=[Person(id=3, name=王兰, sex=女)], 男=[Person(id=1, name=张三, sex=男), Person(id=2, name=李四, sex=男)]} // 将人的姓名作为键，基本信息作为值 // 测试数据不考虑姓名相同的问题 Map\u0026lt;String, Person\u0026gt; personMap = persons.stream().collect(Collectors.toMap(Person::getName, e -\u0026gt; e)); System.out.println(personMap); // {李四=Person(id=2, name=李四, sex=男), 张三=Person(id=1, name=张三, sex=男), 王兰=Person(id=3, name=王兰, sex=女)} } }  我觉得这个问题在开发过程中会经常遇到（手动狗头）\n第二个问题\n@Data @AllArgsConstructor class Field { private Long id; private String name; } @Data @AllArgsConstructor class FieldData { private Long id; private Long fieldId; private String value; } public class FieldTest { public static void main(String[] args) { List\u0026lt;Field\u0026gt; fields = new ArrayList\u0026lt;\u0026gt;(); fields.add(new Field(1L, \u0026quot;field_1\u0026quot;)); fields.add(new Field(2L, \u0026quot;field_2\u0026quot;)); fields.add(new Field(3L, \u0026quot;field_3\u0026quot;)); fields.add(new Field(4L, \u0026quot;field_4\u0026quot;)); List\u0026lt;FieldData\u0026gt; fieldDatas = new ArrayList\u0026lt;\u0026gt;(); fieldDatas.add(new FieldData(5L, 1L, \u0026quot;Stream 好用吗\u0026quot;)); fieldDatas.add(new FieldData(6L, 2L, \u0026quot;Stream 好用\u0026quot;)); fieldDatas.add(new FieldData(7L, 3L, \u0026quot;Stream 牛逼\u0026quot;)); // 说明： // Field 的名称是唯一的 // Field 和 FieldData 是一对一的关系 // 1、 经过多次转换 // 将 Field 的名称 和 Field 转换成 Map Map\u0026lt;String, Field\u0026gt; fieldMap = fields.stream().collect(Collectors.toMap(Field::getName, e -\u0026gt; e)); // FieldData 也转换为 Map Map\u0026lt;Long, FieldData\u0026gt; fieldDataMap = fieldDatas.stream() .collect(Collectors.toMap(FieldData::getFieldId, e -\u0026gt; e)); // 我们想要得到的数据结构 Map\u0026lt;String, FieldData\u0026gt; fieldNameFieldDataMap = new HashMap\u0026lt;\u0026gt;(fieldMap.size()); // 组装我们想要要的数据 fieldMap.forEach((k, v) -\u0026gt; fieldNameFieldDataMap.put(k, fieldDataMap.get(v.getId()))); System.out.println(fieldNameFieldDataMap); // {field_3=FieldData(id=7, fieldId=3, value=Stream 牛逼), field_4=null, // field_1=FieldData(id=5, fieldId=1, value=Stream 好用吗), field_2=FieldData(id=6, // fieldId=2, value=Stream 好用)} // 2、直接一步到胃 // FIXME: 暂时只能做到这种，有没有更好的方法？ List\u0026lt;Map\u0026lt;String, FieldData\u0026gt;\u0026gt; fieldNameFieldDataList = fields.stream() .flatMap(f -\u0026gt; fieldDatas.stream().filter(fd -\u0026gt; fd.getFieldId().equals(f.getId())).map(fieldData -\u0026gt; { Map\u0026lt;String, FieldData\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(f.getName(), fieldData); return map; })).collect(Collectors.toList()); System.out.println(fieldNameFieldDataList); // [{field_1=FieldData(id=5, fieldId=1, value=Stream 好用吗)}, // {field_2=FieldData(id=6, fieldId=2, value=Stream 好用)}, // {field_3=FieldData(id=7, fieldId=3, value=Stream 牛逼)}] // 再次转换 Map\u0026lt;String, FieldData\u0026gt; fieldNameFieldDataMap2 = new HashMap\u0026lt;\u0026gt;(fieldMap.size()); fieldNameFieldDataList.forEach(d -\u0026gt; d.forEach((k, v) -\u0026gt; fieldNameFieldDataMap2.put(k, v))); System.out.println(fieldNameFieldDataMap2); // {field_3=FieldData(id=7, fieldId=3, value=Stream 牛逼), field_1=FieldData(id=5, // fieldId=1, value=Stream 好用吗), field_2=FieldData(id=6, fieldId=2, value=Stream // 好用)} } }  这样就解决了一开始提出的两个问题，当然，还有其他的方法，在这里就不列举了。\n回归正题，在 Rust 中是如何解决这两个问题的呢？\n第一个问题\nuse std::collections::HashMap; #[derive(Debug)] struct Person { id: u64, name: String, sex: String, } fn main() { let persons = [ Person { id: 1, name: \u0026quot;张三\u0026quot;.to_string(), sex: \u0026quot;男\u0026quot;.to_string(), }, Person { id: 2, name: \u0026quot;李四\u0026quot;.to_string(), sex: \u0026quot;男\u0026quot;.to_string(), }, Person { id: 3, name: \u0026quot;王兰\u0026quot;.to_string(), sex: \u0026quot;女\u0026quot;.to_string(), }, ]; // 1、先将性别放进 HashMap 中，然后遍历 HashMap 和 persons 数组，将 persons 中满足 HashMap 键的 person 放到对应的键下面。 // 首先想到的就是这种方法 let mut sex_map = persons .iter() .map(|p| (p.sex.clone(), Vec::new())) .collect::\u0026lt;HashMap\u0026lt;_, _\u0026gt;\u0026gt;(); for snm in sex_map.iter_mut() { persons.iter().for_each(|p| { if p.sex.eq(snm.0) { snm.1.push(p); } }) } println!(\u0026quot;{:?}\u0026quot;, sex_map); // {\u0026quot;女\u0026quot;: [Person { id: 3, name: \u0026quot;王兰\u0026quot;, sex: \u0026quot;女\u0026quot; }], \u0026quot;男\u0026quot;: [Person { id: 1, name: \u0026quot;张三\u0026quot;, sex: \u0026quot;男\u0026quot; }, Person { id: 2, name: \u0026quot;李四\u0026quot;, sex: \u0026quot;男\u0026quot; }]} // 2、使用 fold let sex_map = persons.iter().fold(HashMap::with_capacity(2), |mut m, p| { m.insert( p.sex.clone(), persons .iter() .filter(|pp| pp.sex == p.sex) .collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;(), ); m }); println!(\u0026quot;{:?}\u0026quot;, sex_map); // {\u0026quot;女\u0026quot;: [Person { id: 3, name: \u0026quot;王兰\u0026quot;, sex: \u0026quot;女\u0026quot; }], \u0026quot;男\u0026quot;: [Person { id: 1, name: \u0026quot;张三\u0026quot;, sex: \u0026quot;男\u0026quot; }, Person { id: 2, name: \u0026quot;李四\u0026quot;, sex: \u0026quot;男\u0026quot; }]} }  第二个问题\nuse std::collections::HashMap; #[derive(Debug)] struct Field { id: u64, name: String, } #[derive(Debug)] struct FieldData { id: u64, field_id: u64, value: String, } fn main() { let fields = [ Field { id: 1, name: \u0026quot;field_1\u0026quot;.to_string(), }, Field { id: 2, name: \u0026quot;field_2\u0026quot;.to_string(), }, Field { id: 3, name: \u0026quot;field_3\u0026quot;.to_string(), }, Field { id: 4, name: \u0026quot;field_4\u0026quot;.to_string(), }, ]; let field_datas = [ FieldData { id: 5, field_id: 1, value: \u0026quot;Rust 牛逼!\u0026quot;.to_string(), }, FieldData { id: 6, field_id: 2, value: \u0026quot;Rust 牛逼!!\u0026quot;.to_string(), }, FieldData { id: 7, field_id: 3, value: \u0026quot;Rust 牛逼!!!\u0026quot;.to_string(), }, ]; // 说明： // Field 的名称是唯一的 // Field 和 FieldData 是一对一的关系 // 1、 let field_map = fields .iter() .fold(HashMap::with_capacity(fields.len()), |mut a, b| { a.insert(b.name.clone(), b); a }); let field_data_map = field_datas .iter() .fold(HashMap::with_capacity(field_datas.len()), |mut a, b| { a.insert(b.field_id, b); a }); let mut field_name_field_data_map = HashMap::with_capacity(fields.len()); field_map.iter().for_each(|(k, v)| { field_name_field_data_map.insert(k.clone(), field_data_map.get(\u0026amp;v.id)); }); println!(\u0026quot;{:?}\u0026quot;, field_name_field_data_map); // {\u0026quot;field_1\u0026quot;: Some(FieldData { id: 5, field_id: 1, value: \u0026quot;Rust 牛逼!\u0026quot; }), \u0026quot;field_2\u0026quot;: Some(FieldData { id: 6, field_id: 2, value: \u0026quot;Rust 牛逼!!\u0026quot; }), \u0026quot;field_3\u0026quot;: Some(FieldData { id: 7, field_id: 3, value: \u0026quot;Rust 牛逼!!!\u0026quot; }), \u0026quot;field_4\u0026quot;: None} // 2 、使用 fold 和 filter_map let field_name_field_data_map = fields.iter().fold(HashMap::new(), |mut a, b| { a.insert( b.name.clone(), field_datas .iter() .filter_map(move |fd| if fd.field_id == b.id { Some(fd) } else { None }) .next(), ); a }); println!(\u0026quot;{:?}\u0026quot;, field_name_field_data_map); // {\u0026quot;field_1\u0026quot;: Some(FieldData { id: 5, field_id: 1, value: \u0026quot;Rust 牛逼!\u0026quot; }), \u0026quot;field_3\u0026quot;: Some(FieldData { id: 7, field_id: 3, value: \u0026quot;Rust 牛逼!!!\u0026quot; }), \u0026quot;field_4\u0026quot;: None, \u0026quot;field_2\u0026quot;: Some(FieldData { id: 6, field_id: 2, value: \u0026quot;Rust 牛逼!!\u0026quot; })} }  虽然实现的方法不一定是最好的，但是还是实现了想要达到的效果。😆\n这里就起个抛个砖引个玉的效果。\n嗯~~，这里暂时不介绍 fold filter_map filter for_each等方法的使用，后面的文章可能会逐一介绍。\n如果想要更加熟练的使用这些方法，那还得勤加练习才行。\n","id":14,"section":"posts","summary":"首先，先在这里抛出 两个问题 1. 如何将一个 List 转换为一个 HashMap 2. 如何将两个 List 转换为一个 HashMap 让我们来看看 在 Java 中是如何实现的。😄 第一个问题 @Data @AllArgsConstructor public class Person { private Long id;","tags":["Rust","Rust迭代器"],"title":"关于Rust迭代器的一些骚操作","uri":"https://littleguest.github.io/posts/rust-iterator-group/","year":"2021"},{"content":"首先来看看代码\nMap\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(2); map.put(\u0026quot;reportNo\u0026quot;, null); map.put(\u0026quot;reportDate\u0026quot;, new Date()); System.out.println(JSON.toJSONString(map));  输出结果为\n{\u0026quot;reportDate\u0026quot;:1611756215215}  为什么会出现这种情况呢？\n通过分析源码得知\nif (value == null) { if (!SerializerFeature.isEnabled(out.features, features, SerializerFeature.WriteMapNullValue)) { continue; } }  当值为 null 时，默认是不会被序列化的，但是我们有时候是需要的，那么如何解决呢？\n解决方法\n通过刚才的源码得知，可以指定 SerializerFeature.WriteMapNullValue 来序列化为 null 的值。\nMap\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(2); map.put(\u0026quot;reportNo\u0026quot;, null); map.put(\u0026quot;reportDate\u0026quot;, new Date()); System.out.println(JSON.toJSONString(map, SerializerFeature.WriteMapNullValue));  输出结果为\n{\u0026quot;reportDate\u0026quot;:1611757294826,\u0026quot;reportNo\u0026quot;:null}  ","id":15,"section":"posts","summary":"首先来看看代码 Map\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(2); map.put(\u0026quot;reportNo\u0026quot;, null); map.put(\u0026quot;reportDate\u0026quot;, new Date()); System.out.println(JSON.toJSONString(map)); 输出结果为 {\u0026quot;reportDate\u0026quot;:1611756215215} 为什么会出现这种情况呢？ 通过分析源码得知 if (value == null) { if (!SerializerFeature.isEnabled(out.features, features, SerializerFeature.WriteMapNullValue)) { continue; } } 当值为 null 时，默认是不会被","tags":["Java"],"title":"FastJson 使用 toJSONString 时字段序列化问题","uri":"https://littleguest.github.io/posts/java-fastjson-serialize/","year":"2021"},{"content":"在开发过程中，避免不了会生成各种 Excel 或者 Word 文件，为了简化我们的工作（有更多的时间摸鱼）或者根据项目的需要，我们有时候需要根据定义好的统一的模板创建一类文件。 那么如何在 Java 中根据模板生成文件呢？\n当然，有很多种方法可以实现，但是今天的主角是 Poi-tl\n 在文档的任何地方做任何事情（Do Anything Anywhere）是poi-tl的星辰大海。\n 该库的文档已经写的很详细了，这里就不去讲如何使用了，废话不多说，直接上代码。\n环境\n jdk11 gradle linux  引依赖\n compile group: \u0026lsquo;com.deepoove\u0026rsquo;, name: \u0026lsquo;poi-tl\u0026rsquo;, version: \u0026lsquo;1.9.1\u0026rsquo;\n  implementation \u0026lsquo;org.springframework:spring-expression:5.3.3\u0026rsquo;\n 首先，定义两个类 TestReport 和 CheckItems\n@Data public class TestReport { private String reportNo; private Date reportDate; private String projectName; private List\u0026lt;CheckItems\u0026gt; checkItems; private Object testerSign; private Date testDate; }  @Data public class CheckItems { private String itemNo; private String checkPosition; private String checkResult; private Integer level; }  定义好模板\n最后编写 main 函数\npublic static void main(String[] args) throws IOException { TestReport dto = new TestReport(); dto.setReportNo(\u0026quot;996\u0026quot;); dto.setReportDate(new Date()); dto.setProjectName(\u0026quot;测试用的检测项目名称\u0026quot;); List\u0026lt;CheckItems\u0026gt; checkItems = CollUtil.newArrayList(); for (int i = 1; i \u0026lt;= 3; i++) { CheckItems checkItem = new CheckItems(); checkItem.setItemNo(\u0026quot;100\u0026quot; + (i - 1)); checkItem.setCheckPosition(\u0026quot;检测部位\u0026quot; + i); checkItem.setCheckResult(\u0026quot;合格\u0026quot;); checkItem.setLevel(i); checkItems.add(checkItem); } dto.setCheckItems(checkItems); ClassPathResource testerSign = new ClassPathResource(\u0026quot;static/5ff7adb306f04.png\u0026quot;); dto.setTesterSign(Pictures.ofStream(testerSign.getInputStream(), PictureType.PNG).size(50, 75).create()); dto.setTestDate(new Date()); ConfigureBuilder configureBuilder = Configure.builder(); configureBuilder.useSpringEL(true); ClassPathResource templateFile = new ClassPathResource(\u0026quot;templates/poi-tl.docx\u0026quot;); XWPFTemplate template = XWPFTemplate.compile(templateFile.getInputStream(), configureBuilder.build()); template.render(dto); template.writeAndClose(new FileOutputStream(\u0026quot;poi-tl.docx\u0026quot;)); }  输出的文件结果\n这个案例我觉得可以应付大部分需求了，也提供了一种使用嵌套表格的操作来渲染多个复杂表格的实现；\n接下来就是摸鱼时间~~~\n","id":16,"section":"posts","summary":"在开发过程中，避免不了会生成各种 Excel 或者 Word 文件，为了简化我们的工作（有更多的时间摸鱼）或者根据项目的需要，我们有时候需要根据定义好的统一的模板","tags":["Java"],"title":"Java根据Word模板生成Word文件","uri":"https://littleguest.github.io/posts/java-word-template/","year":"2021"},{"content":"如何在 Rust 中编写测试 当我们创建一个 lib 项目时，cargo 会帮我们创建一个test模块和一个测试函数\n#[cfg(test)] mod tests { #[test] fn it_works() { assert_eq!(2 + 2, 4); } }  #[test] 用于标记一个 fn 函数 为一个测试函数；#[cfg(test)] 表示只有在运行 cargo test 命令时执行； 当我们运行 cargo test 命令后，会得到一些信息；\nFinished test [unoptimized + debuginfo] target(s) in 0.00s Running target/debug/deps/rust_tour_test-13122ed7b69a820b running 1 test test tests::it_works ... ok test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out Doc-tests rust-tour-test running 0 tests test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out  可以看出，运行 cargo test 时，会运行普通测试函数，还会运行文档中的测试函数；\n。。。\n单元测试 单元测试的目的是在与其他部分隔离的环境中测试每一个单元的代码，以便于快速而准确的某个单元的代码功能是否符合预期。单元测试与他们要测试的代码共同存放在位于 src 目录下相同的文件中。规范是在每个文件中创建包含测试函数的 tests 模块，并使用 cfg(test) 标注模块；\n集成测试 在 Rust 中，集成测试对于你需要测试的库来说完全是外部的。同其他使用库的代码一样使用库文件，也就是说它们只能调用一部分库中的 公有 API 。集成测试的目的是测试库的多个部分能否一起正常工作。一些单独能正确运行的代码单元集成在一起也可能会出现问题，所以集成测试的覆盖率也是很重要的。为了创建集成测试，需要在项目根目录创建一个 tests 目录，与 src 同级。Cargo 知道如何去寻找这个目录中的集成测试文件。接着可以随意在这个目录中创建任意多的测试文件，Cargo 会将每一个文件当作单独的 crate 来编译；\nexample:\nrust_test - src - lib.rs - tests - common - mod.rs - test_add.rs  src/lib.rs\n#[cfg(test)] mod tests { #[test] fn it_works() { assert_eq!(2 + 2, 4); } } pub fn add() -\u0026gt; i32 { 2 + 2 }  tests/test_add.rs\nuse rust_test::add; mod common; #[test] fn test() { assert_eq!(666, common::test_common()); assert_eq!(4, add()); }  tests/common/mod.rs\npub fn test_common() -\u0026gt; i32 { 666 }  ","id":17,"section":"posts","summary":"如何在 Rust 中编写测试 当我们创建一个 lib 项目时，cargo 会帮我们创建一个test模块和一个测试函数 #[cfg(test)] mod tests { #[test] fn it_works() { assert_eq!(2 + 2, 4); } } #[test] 用于标记一个 fn 函","tags":["Rust","测试"],"title":"Rust之旅-测试","uri":"https://littleguest.github.io/posts/rust-tour-test/","year":"2021"},{"content":"Git 杂记  不同类别的修改 (如：Bug修复和功能添加) 要尽量分开提交，以方便以后从历史记录里查找特定的修改内容; Git的标准注解:  第1行：提交修改内容的摘要; 第2行：空行; 第3行以后：修改的理由;   . 可以把所有的文件加入到索引;  ","id":18,"section":"posts","summary":"Git 杂记 不同类别的修改 (如：Bug修复和功能添加) 要尽量分开提交，以方便以后从历史记录里查找特定的修改内容; Git的标准注解: 第1行：提交修改","tags":["Git"],"title":"Git杂记","uri":"https://littleguest.github.io/posts/git-notes/","year":"2021"},{"content":"生命周期与引用有效性 Rust 中的每一个引用都有其 生命周期（lifetime），也就是引用保持有效的作用域。大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样。类似于当因为有多种可能类型的时候必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以 Rust 需要我们使用 泛型生命周期参数 来注明他们的关系，这样就能确保运行时实际使用的引用绝对是有效的。\n生命周期避免了悬垂引用\n借用检查器：比较作用域来确保所有的借用都是有效的\n生命周期语法\n 生命周期参数名称必须以撇号（'）开头，其名称通常全是小写，类似于泛型其名称非常短。\u0026lsquo;a 是大多数人默认使用的名称。生命周期参数注解位于引用的 \u0026amp; 之后，并有一个空格来将引用类型与生命周期注解分隔开；\n 通过在函数签名中指定生命周期参数时，我们并没有改变任何传入值或返回值的生命周期，而是指出任何不满足这个约束条件的值都将被借用检查器拒绝；\n指定生命周期参数的正确方式依赖函数实现的具体功能；\n当从函数返回一个引用，返回值的生命周期参数需要与一个参数的生命周期参数相匹配。如果返回的引用 没有 指向任何一个参数，那么唯一的可能就是它指向一个函数内部创建的值，它将会是一个悬垂引用，因为它将会在函数结束时离开作用域。最好的解决方案是返回一个有所有权的数据类型而不是一个引用；\n生命周期语法是用于将函数的多个参数与其返回值的生命周期进行关联的。一旦他们形成了某种关联，Rust 就有了足够的信息来允许内存安全的操作并阻止会产生悬垂指针亦或是违反内存安全的行为；\n","id":19,"section":"posts","summary":"生命周期与引用有效性 Rust 中的每一个引用都有其 生命周期（lifetime），也就是引用保持有效的作用域。大部分时候生命周期是隐含并可以推断的，正","tags":["Rust","Rust生命周期"],"title":"Rust之旅-生命周期","uri":"https://littleguest.github.io/posts/rust-tour-lifetime/","year":"2021"},{"content":"Rust如何使用泛型 在函数定义中使用泛型\n比如我们定义一个求slice中的最大值的函数，传入的参数是一个元素类型为 T 的slice，返回值也是 T； 如果要在函数体内使用泛型参数，那么必须要在函数签名中声明泛型名称。\nfn largest\u0026lt;T\u0026gt;(list: \u0026amp;[T]) -\u0026gt; T {  结构体定义中的泛型\n必须在结构体名称后面的尖括号中声明泛型参数的名称\n// 一个泛型参数 struct Point\u0026lt;T\u0026gt; { x: T, y: T, } // 多个泛型参数 struct Point2\u0026lt;T, U\u0026gt; { x: T, y: U, }  枚举定义中的泛型\n// 一个泛型参数 pub enum Option\u0026lt;T\u0026gt; { None, Some(T), } // 多个泛型参数 pub enum Result\u0026lt;T, E\u0026gt; { Ok(T), Err(E), }  方法定义中的泛型\nstruct Point\u0026lt;T\u0026gt; { x: T, y: T, } impl\u0026lt;T\u0026gt; Point\u0026lt;T\u0026gt; { fn x(\u0026amp;self) -\u0026gt; \u0026amp;T { \u0026amp;self.x } }  结构体定义中的泛型类型参数并不总是与结构体方法签名中使用的泛型是同一类型。\nstruct Point\u0026lt;T, U\u0026gt; { x: T, y: U, } impl\u0026lt;T, U\u0026gt; Point\u0026lt;T, U\u0026gt; { fn mixup\u0026lt;V, W\u0026gt;(self, other: Point\u0026lt;V, W\u0026gt;) -\u0026gt; Point\u0026lt;T, W\u0026gt; { Point { x: self.x, y: other.y, } } }  Rust 通过在编译时进行泛型代码的 单态化（monomorphization） 来保证效率。单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。\n","id":20,"section":"posts","summary":"Rust如何使用泛型 在函数定义中使用泛型 比如我们定义一个求slice中的最大值的函数，传入的参数是一个元素类型为 T 的slice，返回值也是 T","tags":["Rust","Rust泛型"],"title":"Rust之旅-泛型","uri":"https://littleguest.github.io/posts/rust-tour-generic-type/","year":"2021"},{"content":"Rust中的错误处理 在 Java 中处理异常一般有以下几种方式：\n 使用 try-catch 捕获异常 通过 throw 的方式向上抛异常 在web中全局拦截异常  当然还有其他方式处理异常，这里就不一一列举了。\n好了，回归正题，\n那么在 Rust 中是怎么处理错误的呢？\n来讲怎么处理错误之前，我们首先需要了解标准库中的 std::result::Result 这个枚举\n#[must_use = \u0026quot;this `Result` may be an `Err` variant, which should be handled\u0026quot;] pub enum Result\u0026lt;T, E\u0026gt; { Ok(T), Err(E), }  它是用来返回错误和传播错误的，Ok(T) 代表成功并且包含一个成功值, Err(E) 代表错误并且包含一个错误值， #[must_use] 属性表示返回值 Result 需要被处理，否则编译器会给出警告；\n  最简单粗暴的方式就是直接 unwrap\n unwrap 如果出现错误，直接 panic，一般不推荐使用；  assert_eq!(Ok::\u0026lt;u32, \u0026amp;str\u0026gt;(1).unwrap(), 1); Err::\u0026lt;u32, \u0026amp;str\u0026gt;(\u0026quot;error\u0026quot;).unwrap(); // panic   unwrap_or 如果出现错误，返回给出的值；  assert_eq!(Err::\u0026lt;u32, \u0026amp;str\u0026gt;(\u0026quot;error\u0026quot;).unwrap_or(1), 1);   unwrap_or_else 如果出现错误，返回闭包计算出的值；  assert_eq!(Err::\u0026lt;u32, \u0026amp;str\u0026gt;(\u0026quot;error\u0026quot;).unwrap_or_else(|_| 1), 1); fn count(x: \u0026amp;str) -\u0026gt; usize { x.len() } assert_eq!(Err::\u0026lt;usize, \u0026amp;str\u0026gt;(\u0026quot;error\u0026quot;).unwrap_or_else(count), 5);   unwrap_or_default 如果出现错误，返回改类型的默认值，否则返回 Ok(T) 包含的值；  assert_eq!(Err::\u0026lt;i32, \u0026amp;str\u0026gt;(\u0026quot;error\u0026quot;).unwrap_or_default(), 0); assert_eq!(Err::\u0026lt;bool, \u0026amp;str\u0026gt;(\u0026quot;error\u0026quot;).unwrap_or_default(), false);    或者 expect\nErr::\u0026lt;u32, \u0026amp;str\u0026gt;(\u0026quot;error\u0026quot;).expect(\u0026quot;panic\u0026quot;); // ...thread 'main' panicked at 'panic: \u0026quot;error\u0026quot;',...    我们想要快速获取 Ok(T) 中的值，常用的就是以上这几种 Result 的方法，接下来我们尝试其它途径来处理错误；\n  使用 match 模式匹配\nuse std::fs::File; use std::io::Read; fn main() { let mut file = File::open(\u0026quot;./setting.toml\u0026quot;); match file { Ok(mut f) =\u0026gt; { let mut buf = \u0026quot;\u0026quot;.to_string(); let read = f.read_to_string(\u0026amp;mut buf); match read { Ok(_) =\u0026gt; {} Err(e) =\u0026gt; eprintln!(\u0026quot;read err: {}\u0026quot;, e), } } Err(e) =\u0026gt; eprintln!(\u0026quot;open err: {}\u0026quot;, e), } }  当我们需要处理多个错误时，使用 match 匹配就有点啰嗦了。\n  传播错误 我们可以使用 ? 操作符来简化 match 模式匹配\nuse std::fs::File; use std::io::Read; fn main() -\u0026gt; Result\u0026lt;(), std::io::Error\u0026gt; { let mut file = File::open(\u0026quot;./setting.toml\u0026quot;)?; let mut buf = \u0026quot;\u0026quot;.to_string(); let _ = file.read_to_string(\u0026amp;mut buf)?; Ok(()) }  可以看到使用 ? 极大的简化了我们的代码，当然现在我们只返回来一种错误，接下来我们看看是怎样返回多种错误的；\nuse std::fs::File; use std::io::Read; fn main() -\u0026gt; Result\u0026lt;(), Box\u0026lt;dyn std::error::Error\u0026gt;\u0026gt; { let mut file = File::open(\u0026quot;./Cargo.toml\u0026quot;)?; let mut buf = \u0026quot;\u0026quot;.to_string(); let _ = file.read_to_string(\u0026amp;mut buf)?; \u0026quot;a\u0026quot;.parse::\u0026lt;i32\u0026gt;()?; Ok(()) }    自定义错误 开始自定义错误之前，需要了解标准库 std::error::Error\npub trait Error: Debug + Display { fn source(\u0026amp;self) -\u0026gt; Option\u0026lt;\u0026amp;(dyn Error + 'static)\u0026gt; { ... } fn backtrace(\u0026amp;self) -\u0026gt; Option\u0026lt;\u0026amp;Backtrace\u0026gt; { ... } fn description(\u0026amp;self) -\u0026gt; \u0026amp;str { ... } fn cause(\u0026amp;self) -\u0026gt; Option\u0026lt;\u0026amp;dyn Error\u0026gt; { ... } }  当我们自定义错误时，只需要管 source 这个方法就行了， description 和 cause 已经废弃了，backtrace 在 nightly 版本中还是实验性的（我的版本是 1.49.0）；\nuse std::fmt::{Debug, Display, Formatter}; use std::fs::File; use std::io::{Error, Read}; use std::num::ParseIntError; use std::str::Utf8Error; #[derive(Debug)] enum CustomError { IoErr, ParseIntError(ParseIntError), Utf8Error(Utf8Error), } impl Display for CustomError { fn fmt(\u0026amp;self, f: \u0026amp;mut Formatter\u0026lt;'_\u0026gt;) -\u0026gt; std::fmt::Result { match self { CustomError::IoErr =\u0026gt; write!(f, \u0026quot;io error\u0026quot;), CustomError::ParseIntError(_) =\u0026gt; write!(f, \u0026quot;parse int error\u0026quot;), CustomError::Utf8Error(_) =\u0026gt; write!(f, \u0026quot;utf8 error\u0026quot;), } } } impl std::error::Error for CustomError { fn source(\u0026amp;self) -\u0026gt; Option\u0026lt;\u0026amp;(dyn std::error::Error + 'static)\u0026gt; { match self { CustomError::IoErr =\u0026gt; None, CustomError::ParseIntError(e) =\u0026gt; Some(e), CustomError::Utf8Error(e) =\u0026gt; Some(e), } } } impl From\u0026lt;std::io::Error\u0026gt; for CustomError { fn from(_: Error) -\u0026gt; Self { Self::IoErr } } impl From\u0026lt;ParseIntError\u0026gt; for CustomError { fn from(e: ParseIntError) -\u0026gt; Self { Self::ParseIntError(e) } } impl From\u0026lt;Utf8Error\u0026gt; for CustomError { fn from(e: Utf8Error) -\u0026gt; Self { Self::Utf8Error(e) } } fn main() -\u0026gt; Result\u0026lt;(), CustomError\u0026gt; { let mut file = File::open(\u0026quot;./Cargo.toml\u0026quot;)?; let mut buf = \u0026quot;\u0026quot;.to_string(); let _ = file.read_to_string(\u0026amp;mut buf)?; std::str::from_utf8(\u0026quot;😄\u0026quot;.as_bytes())?; \u0026quot;a\u0026quot;.parse::\u0026lt;i32\u0026gt;()?; Ok(()) }    以上就是我了解的错误处理方式，如果想要更深入了解，可以看看 std::io::Error ；\n","id":21,"section":"posts","summary":"Rust中的错误处理 在 Java 中处理异常一般有以下几种方式： 使用 try-catch 捕获异常 通过 throw 的方式向上抛异常 在web中全局拦截异常 当然还有其他方式处理异常，这","tags":["Rust","Rust错误处理"],"title":"Rust之旅-错误处理","uri":"https://littleguest.github.io/posts/rust-tour-error-handle/","year":"2021"},{"content":"记一次Java Stream 去重操作 为了重现当时的错误，我会尽量保持一致，只是类名和类的属性不一样而已，现定义如下两个类\npublic class BaseEntity implements Serializable { private Long id; public BaseEntity() { } public Long getId() { return id; } public void setId(Long id) { this.id = id; } }  @Data public class Entity extends BaseEntity { private Long id; private String field; }  Entity 是继承 BaseEntity ，并且 BaseEntity 是实现了 Serializable 这个接口\n接下来编写测试代码\npublic static void main(String[] args) { List\u0026lt;Entity\u0026gt; entities = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 5; i++) { Entity entity = new Entity(); entity.setId(1L); entity.setField(\u0026quot;field\u0026quot;); entities.add(entity); } System.out.println(entities.stream().distinct().collect(Collectors.toList())); }  首先定义了一个装 Entity 的 ArrayList ，向其中放入5个实例，最后打印去重后的结果，输出结果如下\n\u0026gt; Task :Test.main() [Entity(id=1, field=field)]  可以看到，结果跟我们预期的结果是一样的，是去重后的结果。\n当我们定义 Entity 时，编辑器会提示像这种的警告 当我使用编辑器快捷键导入时，代码变成了如下：\n@EqualsAndHashCode(callSuper = true) @Data public class Entity extends BaseEntity { private Long id; private String field; }  好了，这个就是错误的开端了，当再次运行的测试代码的时候，结果变成了\n\u0026gt; Task :Test.main() [Entity(id=1, field=field), Entity(id=1, field=field), Entity(id=1, field=field), Entity(id=1, field=field), Entity(id=1, field=field)]  嗯~~，怎么肥事，为啥结果和预期的不一样了呢？\n让我们一步一步来分析\n首先通过分析 stream distinct 源码及源码文档得知，它底层是使用 HashSet 来实现去重处理的，HashSet 本身又是基于 HashMap 来去重的，正如我们平时使用 HashMap 时需要保证 HashMap 的 key 必须重写 equals 以及 hashCode 方法，要想使用 stream 的 distinct 方法去重也必须保证涉及的类必须重写 equals 以及 hashCode 方法，否则就可能无法去重。\n同时 @Data 注解相当于 @Getter,@Setter,@RequiredArgsConstructor,@ToString,@EqualsAndHashCode,@Value 这几个注解，使用 @Data 注解就重写了 equeals 和 hashCode 方法，所以最开始是没问题的，当我们为了消除警告而导入 @EqualsAndHashCode 注解时，为什么又不行了呢？\n这里要注意的是 @EqualsAndHashCode 的 callSuper 这个参数，这个参数表明当我们子类和父类中有相同属性时，要不要调用父类的 equeals 和 hashCode 方法，默认是 false，当我们指定为 true 时，就会调用父类的 equeals 和 hashCode 方法来进行比较，就会判定为不相等，所以才会出现第二种情况。\n那我们该怎么解决呢？\n我们只要将 @EqualsAndHashCode 注解的 callSuper 改为 false 或直接删除 @EqualsAndHashCode 即可。\n","id":22,"section":"posts","summary":"记一次Java Stream 去重操作 为了重现当时的错误，我会尽量保持一致，只是类名和类的属性不一样而已，现定义如下两个类 public class BaseEntity implements Serializable { private Long id; public BaseEntity() { } public Long getId()","tags":["Java","Lombok","Stream"],"title":"Java-记一次Stream去重操作","uri":"https://littleguest.github.io/posts/java-stream-distinct/","year":"2021"},{"content":"  \u0026amp; 表示是一个引用，它允许多出代码访问同一处数据，而无需在内存中多次拷贝；\n  关联函数是针对类型实现的；\n  语义化版本；\n  变量是默认不可改变的，但通过加 mut 来使其改变；\n  常量总是不变的；\n  Rust 有四种基本的标量类型：整型，浮点型，布尔类型和字符类型；\n 整型：有符号（[$-2^(n-1)$:$2^(n-1) - 1$]），无符号（[0:$2^n - 1$]）    长度 有符号 无符号     8-bit i8 u8   16-bit i16 u16   32-bit i32（默认） u32   64-bit i64 u64   128-bit i128 u128   arch isize usize     浮点型：f32，f64（默认） 布尔类型：true，false 字符类型： char    所有权规则\n Rust中的每一个值都有一个被称其为 所有者 （owner）的变量; 值在任一时刻有且只有一个所有者； 当所有者（变量）离开作用域，这个值将被丢弃；   变量和数据交互的方式：move，clone； Rust永远不会自动创建数据的“深拷贝”； Rust不允许自身或其任何部分实现了 Drop trait的类型使用 Copy trait，以下是一些 Copy 的类型：  所有整数类型； 布尔类型； 所有浮点类型； 字符类型； 元组，当且仅当其包含的类型都是 Copy 的时候；   \u0026amp; 表示引用，它允许使用值但不获取其所有权； 将获取引用作为函数参数称为 借用（borrowing）； 默认不允许修改引用的值； 引用的规则：  在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用； 引用必须总是有效的；   产生数据竞争的方式：  两个或更多指针同时访问统一数据； 至少有一个指针被用来写入数据； 没有同步数据访问的机制；      Rust有一个叫自动引用和解引用的功能。方法调用是Rust中少数几个拥有这种行为的地方；如：当使用 object.something() 调用方法时，Rust 会自动为 object 添加 \u0026amp;、\u0026amp;mut 或 * 以便使 object 与方法签名匹配；\n  模块系统：\n 包（Packages）：Cargo的一个功能，它允许你构建、测试和分享crate； Crates：一个模块的树形结构，它形成了库和二进制项目； 模块（Modules） 和use：它允许你控制作用域和路径的私有性； 路径（path）：一个命名例如结构体、函数或模块等项的方式；   一个包中至多只能包含一个crate（library crate）；包中可以包含任意多个二进制crate（binary crate）；包中至少包含一个crate，无论是库的还是二进制的； 路径的两种形式：  绝对路径：从crate根开始，以crate名或者字面着crate开头； 相对路径：从当前模块开始，以 self、super或当前模块的标识符开头；   Rust 中默认所有项（函数、方法、结构体、枚举、模块和常量）都是私有的。父模块中的项不能使用子模块中的私有项，但是子模块中的项可以使用他们父模块中的项；    Rust的核心语言中只有一种字符串类型：str，字符串slice，它通常以被借用的形式出现，\u0026amp;str；称作 String 的类型是由标准库提供的，而没有写进核心语言部分，它是可增长的、可变的、有所有权的、UTF-8 编码的字符串类型。当 Rustacean 们谈到 Rust 的 “字符串”时，它们通常指的是 String 和字符串 slice \u0026amp;str 类型，而不仅仅是其中之一；\n  \u0026amp;String 可以被强转为 \u0026amp;str ；\n  Rust 通过在编译时进行泛型代码的 单态化（monomorphization）来保证效率。单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程；\n  孤儿规则（orphan rule）：只有当 trait 或者要实现 trait 的类型位于 crate 的本地作用域时，才能为该类型实现 trait；\n  Trait Bound 语法：impl Trait 语法适用于直观的例子，它不过是一个较长形式的语法糖；\n  Rust 中的每一个引用都有其 生命周期（lifetime），也就是引用保持有效的作用域；\n  Rust 编译器有一个 借用检查器（borrow checker），它比较作用域来确保所有的借用都是有效的；\n  被编码进 Rust 引用分析的模式被称为 生命周期省略规则（lifetime elision rules）。这并不是需要程序员遵守的规则；这些规则是一系列特定的场景，此时编译器会考虑，如果代码符合这些场景，就无需明确指定生命周期；\n  函数或方法的参数的生命周期被称为 输入生命周期（input lifetimes），而返回值的生命周期被称为 输出生命周期（output lifetimes）；\n  编译器采用三条规则来判断引用何时不需要明确的注解。第一条规则适用于输入生命周期，后两条规则适用于输出生命周期。如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将会停止并生成错误。这些规则适用于 fn 定义，以及 impl 块：\n 第一条规则是每一个是引用的参数都有它自己的生命周期参数。换句话说就是，有一个引用参数的函数有一个生命周期参数：fn foo\u0026lt;'a\u0026gt;(x: \u0026amp;'a i32)，有两个引用参数的函数有两个不同的生命周期参数，fn foo\u0026lt;'a, 'b\u0026gt;(x: \u0026amp;'a i32, y: \u0026amp;'b i32)，依此类推； 第二条规则是如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：fn foo\u0026lt;'a\u0026gt;(x: \u0026amp;'a i32) -\u0026gt; \u0026amp;'a i32； 第三条规则是如果方法有多个输入生命周期参数并且其中一个参数是 \u0026amp;self 或 \u0026amp;mut self，说明是个对象的方法(method), 那么所有输出生命周期参数被赋予 self 的生命周期。第三条规则使得方法更容易读写，因为只需更少的符号；    静态生命周期：'static，其生命周期能够存活于整个程序期间。因此所有的字符串字面值都是 'static 的；\n  测试驱动开发（Test Driven Development, TDD）遵循如下步骤：\n 编写一个失败的测试，并运行它以确保它失败的原因是你所期望的。 编写或修改足够的代码来使新的测试通过。 重构刚刚增加或修改的代码，并确保测试仍然能通过。 从步骤 1 开始重复！    所有的闭包都实现了 trait Fn、FnMut 或 FnOnce中的一个：\n FnOnce 消费从周围作用域捕获的变量，闭包周围的作用域被称为其 环境，environment。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 Once 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次； FnMut 获取可变的借用值所以可以改变其环境； Fn 从其环境获取不可变的借用值；、    由于所有闭包都可以被调用至少一次，所以所有闭包都实现了 FnOnce。那些并没有移动被捕获变量的所有权到闭包中的闭包也实现了 FnMut，而不需要对被捕获的变量进行可变访问的闭包则也实现了 Fn；\n  如果希望强制闭包获取其使用的环境值的所有权，可以在参数列表前使用 move 关键字。（这个技巧在将闭包传递给新线程以便将数据移动到新线程中时最为实用）；\n  在 Rust 中，迭代器是 惰性的（lazy），这意味着在调用方法使用迭代器之前它都不会有效果；\n  迭代器是 Rust 的零成本抽象（zero-cost abstractions）之一，它意味着抽象并不会引入运行时开销；\n  指针（pointer）是一个包含内存地址的变量的通用概念。这个地址引用，或“指向”（points at）一些其他数据；智能指针（smart pointers）是一类数据结构，他们的表现类似指针，但是也拥有额外的元数据和功能；在 Rust 中，普通引用和智能指针的一个额外的区别是引用一类只借用数据的指针；相反，在大部分情况下，智能指针 拥有 他们指向的数据；\n  只能指针通常使用结构体实现。智能指针区别于常规结构体的显著特征在于其实现了 Deref 和 Drop trait；\n  Rust 在发现类型和 trait 实现满足三种情况时会进行解引用强制多态：\n 当 T: Deref\u0026lt;Target=U\u0026gt; 时从 \u0026amp;T 到 \u0026amp;U； 当 T: DerefMut\u0026lt;Target=U\u0026gt; 时从 \u0026amp;mut T 到 \u0026amp;mut U； 当 T: Deref\u0026lt;Target=U\u0026gt; 时从 \u0026amp;mut T 到 \u0026amp;U；    Rust 也会将可变引用强转为不可变引用。但是反之是 不可能 的：不可变引用永远也不能强转为可变引用；\n  并发编程（Concurrent programming）：代表程序的不同部分相互独立的执行；并行编程parallel programming）：代表程序不同部分同时执行\n  Rust 标准库只提供了 1:1 线程模型实现。\n  move 闭包经常与 std:🧵:spawn 一起使用，允许在一个线程中使用另外一个线程的数据；\n  Rust 中一个实现消息传递并发的主要工具是 通道（channel），由发送者（transmitter）和接收者（receiver）组成，当发送者或接收者任一被丢弃时可以认为通道被关闭了；\n  std::sync::mpsc 是 多个生产者，单个消费者（multiple producer, single consumer）；\n  互斥器一次只允许一个线程访问数据；\n  ","id":23,"section":"posts","summary":"\u0026amp; 表示是一个引用，它允许多出代码访问同一处数据，而无需在内存中多次拷贝； 关联函数是针对类型实现的； 语义化版本； 变量是默认不可改变的，但通过加","tags":["Rust","Rust杂记"],"title":"Rust-杂记","uri":"https://littleguest.github.io/posts/rust-notes/","year":"2020"},{"content":"Rust交叉编译问题 $ cargo build --release --target armv7-unknown-linux-musleabihf  下面是错误日志\nerror: failed to run custom build command for `openssl-sys v0.9.58` Caused by: process didn't exit successfully: `~/workspace/raspi_ip_email/target/release/build/openssl-sys-86e8fa49856e4dc9/build-script-main` (exit code: 101) --- stdout cargo:rustc-cfg=const_fn cargo:rerun-if-env-changed=ARMV7_UNKNOWN_LINUX_MUSLEABIHF_OPENSSL_LIB_DIR ARMV7_UNKNOWN_LINUX_MUSLEABIHF_OPENSSL_LIB_DIR unset cargo:rerun-if-env-changed=OPENSSL_LIB_DIR OPENSSL_LIB_DIR unset cargo:rerun-if-env-changed=ARMV7_UNKNOWN_LINUX_MUSLEABIHF_OPENSSL_INCLUDE_DIR ARMV7_UNKNOWN_LINUX_MUSLEABIHF_OPENSSL_INCLUDE_DIR unset cargo:rerun-if-env-changed=OPENSSL_INCLUDE_DIR OPENSSL_INCLUDE_DIR unset cargo:rerun-if-env-changed=ARMV7_UNKNOWN_LINUX_MUSLEABIHF_OPENSSL_DIR ARMV7_UNKNOWN_LINUX_MUSLEABIHF_OPENSSL_DIR unset cargo:rerun-if-env-changed=OPENSSL_DIR OPENSSL_DIR unset cargo:rerun-if-env-changed=OPENSSL_NO_PKG_CONFIG cargo:rerun-if-env-changed=PKG_CONFIG_ALLOW_CROSS_armv7-unknown-linux-musleabihf cargo:rerun-if-env-changed=PKG_CONFIG_ALLOW_CROSS_armv7_unknown_linux_musleabihf cargo:rerun-if-env-changed=TARGET_PKG_CONFIG_ALLOW_CROSS cargo:rerun-if-env-changed=PKG_CONFIG_ALLOW_CROSS cargo:rerun-if-env-changed=PKG_CONFIG_armv7-unknown-linux-musleabihf cargo:rerun-if-env-changed=PKG_CONFIG_armv7_unknown_linux_musleabihf cargo:rerun-if-env-changed=TARGET_PKG_CONFIG cargo:rerun-if-env-changed=PKG_CONFIG cargo:rerun-if-env-changed=PKG_CONFIG_SYSROOT_DIR_armv7-unknown-linux-musleabihf cargo:rerun-if-env-changed=PKG_CONFIG_SYSROOT_DIR_armv7_unknown_linux_musleabihf cargo:rerun-if-env-changed=TARGET_PKG_CONFIG_SYSROOT_DIR cargo:rerun-if-env-changed=PKG_CONFIG_SYSROOT_DIR run pkg_config fail: \u0026quot;pkg-config has not been configured to support cross-compilation.\\n\\n Install a sysroot for the target platform and configure it via\\n PKG_CONFIG_SYSROOT_DIR and PKG_CONFIG_PATH, or install a\\n cross-compiling wrapper for pkg-config and set it via\\n PKG_CONFIG environment variable.\u0026quot; --- stderr thread 'main' panicked at ' Could not find directory of OpenSSL installation, and this `-sys` crate cannot proceed without this knowledge. If OpenSSL is installed and this crate had trouble finding it, you can set the `OPENSSL_DIR` environment variable for the compilation process. Make sure you also have the development packages of openssl installed. For example, `libssl-dev` on Ubuntu or `openssl-devel` on Fedora. If you're in a situation where you think the directory *should* be found automatically, please open a bug at https://github.com/sfackler/rust-openssl and include information about your system as well as this message. $HOST = x86_64-unknown-linux-gnu $TARGET = armv7-unknown-linux-musleabihf openssl-sys = 0.9.58 ', ~/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/openssl-sys-0.9.58/build/find_normal.rs:157:5 note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace warning: build failed, waiting for other jobs to finish... error: build failed test@test:~/workspace/raspi_ip_email$ clear test@test:~/workspace/raspi_ip_email$ cargo build --release --target armv7-unknown-linux-musleabihf Compiling openssl-sys v0.9.58 Compiling unicode-normalization v0.1.16 Compiling quote v1.0.7 Compiling getrandom v0.1.15 Compiling parking_lot_core v0.8.1 Compiling hostname v0.3.1 Compiling time v0.1.44 Compiling num-traits v0.2.14 error: failed to run custom build command for `openssl-sys v0.9.58` Caused by: process didn't exit successfully: `~/workspace/raspi_ip_email/target/release/build/openssl-sys-86e8fa49856e4dc9/build-script-main` (exit code: 101) --- stdout cargo:rustc-cfg=const_fn cargo:rerun-if-env-changed=ARMV7_UNKNOWN_LINUX_MUSLEABIHF_OPENSSL_LIB_DIR ARMV7_UNKNOWN_LINUX_MUSLEABIHF_OPENSSL_LIB_DIR unset cargo:rerun-if-env-changed=OPENSSL_LIB_DIR OPENSSL_LIB_DIR unset cargo:rerun-if-env-changed=ARMV7_UNKNOWN_LINUX_MUSLEABIHF_OPENSSL_INCLUDE_DIR ARMV7_UNKNOWN_LINUX_MUSLEABIHF_OPENSSL_INCLUDE_DIR unset cargo:rerun-if-env-changed=OPENSSL_INCLUDE_DIR OPENSSL_INCLUDE_DIR unset cargo:rerun-if-env-changed=ARMV7_UNKNOWN_LINUX_MUSLEABIHF_OPENSSL_DIR ARMV7_UNKNOWN_LINUX_MUSLEABIHF_OPENSSL_DIR unset cargo:rerun-if-env-changed=OPENSSL_DIR OPENSSL_DIR unset cargo:rerun-if-env-changed=OPENSSL_NO_PKG_CONFIG cargo:rerun-if-env-changed=PKG_CONFIG_ALLOW_CROSS_armv7-unknown-linux-musleabihf cargo:rerun-if-env-changed=PKG_CONFIG_ALLOW_CROSS_armv7_unknown_linux_musleabihf cargo:rerun-if-env-changed=TARGET_PKG_CONFIG_ALLOW_CROSS cargo:rerun-if-env-changed=PKG_CONFIG_ALLOW_CROSS cargo:rerun-if-env-changed=PKG_CONFIG_armv7-unknown-linux-musleabihf cargo:rerun-if-env-changed=PKG_CONFIG_armv7_unknown_linux_musleabihf cargo:rerun-if-env-changed=TARGET_PKG_CONFIG cargo:rerun-if-env-changed=PKG_CONFIG cargo:rerun-if-env-changed=PKG_CONFIG_SYSROOT_DIR_armv7-unknown-linux-musleabihf cargo:rerun-if-env-changed=PKG_CONFIG_SYSROOT_DIR_armv7_unknown_linux_musleabihf cargo:rerun-if-env-changed=TARGET_PKG_CONFIG_SYSROOT_DIR cargo:rerun-if-env-changed=PKG_CONFIG_SYSROOT_DIR run pkg_config fail: \u0026quot;pkg-config has not been configured to support cross-compilation.\\n\\n Install a sysroot for the target platform and configure it via\\n PKG_CONFIG_SYSROOT_DIR and PKG_CONFIG_PATH, or install a\\n cross-compiling wrapper for pkg-config and set it via\\n PKG_CONFIG environment variable.\u0026quot; --- stderr thread 'main' panicked at ' Could not find directory of OpenSSL installation, and this `-sys` crate cannot proceed without this knowledge. If OpenSSL is installed and this crate had trouble finding it, you can set the `OPENSSL_DIR` environment variable for the compilation process. Make sure you also have the development packages of openssl installed. For example, `libssl-dev` on Ubuntu or `openssl-devel` on Fedora. If you're in a situation where you think the directory *should* be found automatically, please open a bug at https://github.com/sfackler/rust-openssl and include information about your system as well as this message. $HOST = x86_64-unknown-linux-gnu $TARGET = armv7-unknown-linux-musleabihf openssl-sys = 0.9.58 ', ~/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/openssl-sys-0.9.58/build/find_normal.rs:157:5 note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace warning: build failed, waiting for other jobs to finish... error: build failed  解决方案  https://github.com/getsentry/rust-musl-cross\n ","id":24,"section":"posts","summary":"Rust交叉编译问题 $ cargo build --release --target armv7-unknown-linux-musleabihf 下面是错误日志 error: failed to run custom build command for `openssl-sys v0.9.58` Caused by: process didn't exit successfully: `~/workspace/raspi_ip_email/target/release/build/openssl-sys-86e8fa49856e4dc9/build-script-main` (exit code: 101) --- stdout cargo:rustc-cfg=const_fn cargo:rerun-if-env-changed=ARMV7_UNKNOWN_LINUX_MUSLEABIHF_OPENSSL_LIB_DIR ARMV7_UNKNOWN_LINUX_MUSLEABIHF_OPENSSL_LIB_DIR unset cargo:rerun-if-env-changed=OPENSSL_LIB_DIR OPENSSL_LIB_DIR unset cargo:rerun-if-env-changed=ARMV7_UNKNOWN_LINUX_MUSLEABIHF_OPENSSL_INCLUDE_DIR ARMV7_UNKNOWN_LINUX_MUSLEABIHF_OPENSSL_INCLUDE_DIR unset cargo:rerun-if-env-changed=OPENSSL_INCLUDE_DIR OPENSSL_INCLUDE_DIR unset cargo:rerun-if-env-changed=ARMV7_UNKNOWN_LINUX_MUSLEABIHF_OPENSSL_DIR ARMV7_UNKNOWN_LINUX_MUSLEABIHF_OPENSSL_DIR unset cargo:rerun-if-env-changed=OPENSSL_DIR OPENSSL_DIR unset cargo:rerun-if-env-changed=OPENSSL_NO_PKG_CONFIG cargo:rerun-if-env-changed=PKG_CONFIG_ALLOW_CROSS_armv7-unknown-linux-musleabihf cargo:rerun-if-env-changed=PKG_CONFIG_ALLOW_CROSS_armv7_unknown_linux_musleabihf cargo:rerun-if-env-changed=TARGET_PKG_CONFIG_ALLOW_CROSS cargo:rerun-if-env-changed=PKG_CONFIG_ALLOW_CROSS cargo:rerun-if-env-changed=PKG_CONFIG_armv7-unknown-linux-musleabihf","tags":["Rust","树莓派","交叉编译"],"title":"Rust-交叉编译-树莓派","uri":"https://littleguest.github.io/posts/rust-cross-compiling-raspberrypi/","year":"2020"},{"content":"树莓派 初体验 在 Linux 系统上如何连接没有屏幕的树莓派    准备或制作树莓派的镜像；   如何制作？  首先到官网下载一个适合自己的镜像，我选择的是下面这个镜像；  使用BalenaEtcher烧录 树莓派 镜像，烧录完成后，会有两个分区boot和rootfs；      在boot下创建wpa_supplicant.conf文件，内容如下；   country=CN ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 network={ ssid=\u0026quot;\u0026quot; psk=\u0026quot;\u0026quot; priority = 1 }  说明：  ssid: 网络的ssid； psk： 密码； priority: 连接优先级，数字越大优先级越高（不可以是负数）； scan_ssid：连接隐藏WiFi时需要指定该值为1；    在boot下创建不带扩展名的ssh文件；    启动树莓派，稍等几分钟；    使用arp-scan列出局域网内的主机；  sudo arp-scan -interface wlp3s0 -localnet    使用ssh登录到树莓派，树莓派默认账号为pi，默认密码为raspberry;     到此为止，我们已经连上树莓派了\n  那么如何能看到树莓派的桌面呢？     下载VNC Server到树莓派；    安装并启动VNC Server;     下载VNC Viewer并运行；    输入刚才启动VNC Server生成的192.168.2.100:1，一直continue，输入树莓派的账号和密码，完成之后就可以看到树莓派的桌面了；       ","id":25,"section":"posts","summary":"树莓派 初体验 在 Linux 系统上如何连接没有屏幕的树莓派 准备或制作树莓派的镜像； 如何制作？ 首先到官网下载一个适合自己的镜像，我选择的是下面这个镜像； 使","tags":["Linux","树莓派"],"title":"树莓派 初体验","uri":"https://littleguest.github.io/posts/raspberrypi-first-experience/","year":"2020"},{"content":"如何在 VSCode 中调试 Rust 来源：如何在 VSCode 中调试 Rust 代码\n 安装 CodeLLDB 创建 launch.json 文件，添加配置如下  { \u0026quot;version\u0026quot;: \u0026quot;0.2.0\u0026quot;, \u0026quot;configurations\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;(Linux) Launch\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;lldb\u0026quot;, \u0026quot;request\u0026quot;: \u0026quot;launch\u0026quot;, \u0026quot;program\u0026quot;: \u0026quot;${workspaceRoot}/target/debug/文件名称\u0026quot;, \u0026quot;args\u0026quot;: [], \u0026quot;cwd\u0026quot;: \u0026quot;${workspaceRoot}\u0026quot; } ] }  ","id":26,"section":"posts","summary":"如何在 VSCode 中调试 Rust 来源：如何在 VSCode 中调试 Rust 代码 安装 CodeLLDB 创建 launch.json 文件，添加配置如下 { \u0026quot;version\u0026quot;: \u0026quot;0.2.0\u0026quot;, \u0026quot;configurations\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;(Linux) Launch\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;lldb\u0026quot;, \u0026quot;request\u0026quot;: \u0026quot;launch\u0026quot;, \u0026quot;program\u0026quot;: \u0026quot;${workspaceRoo","tags":["Rust","调试Rust"],"title":"VSCode中调试Rust","uri":"https://littleguest.github.io/posts/vscode-debug-rust/","year":"2020"},{"content":"if 表达式 fn main() { let number = 3; if number \u0026lt; 5 { println!(\u0026quot;condition was true\u0026quot;); } else { println!(\u0026quot;condition was false\u0026quot;); } }  使用 else if 处理多重条件 let number = 6; if number % 4 == 0 { println!(\u0026quot;number is divisible by 4\u0026quot;); } else if number % 3 == 0 { println!(\u0026quot;number is divisible by 3\u0026quot;); } else if number % 2 == 0 { println!(\u0026quot;number is divisible by 2\u0026quot;); } else { println!(\u0026quot;number is not divisible by 4, 3, or 2\u0026quot;); }  在 let 语句中使用 if fn main() { let condition = true; let number = if condition { 5 } else { 6 }; println!(\u0026quot;The value of number is: {}\u0026quot;, number); }  使用 loop 重复执行代码，从循环返回 fn main() { let mut count = 0_u32; println!(\u0026quot;Let's count until infinity!\u0026quot;); // 无限循环 loop { count += 1; if count == 3 { println!(\u0026quot;three\u0026quot;); // 跳过这次迭代的剩下内容 continue; } println!(\u0026quot;{}\u0026quot;, count); if count == 5 { println!(\u0026quot;OK, that's enough\u0026quot;); // 退出循环 break; } } 'outer: loop { println!(\u0026quot;Entered the outer loop\u0026quot;); 'inner: loop { println!(\u0026quot;Entered the inner loop\u0026quot;); // 这只是中断内部的循环 // break; // 这会中断外层循环 break 'outer; } println!(\u0026quot;This point will never be reached\u0026quot;); } println!(\u0026quot;Exited the outer loop\u0026quot;); let mut counter = 0; let result = loop { counter += 1; if counter == 10 { break counter * 2; } }; assert_eq!(result, 20); }  while 条件循环 fn main() { let mut number = 3; while number != 0 { println!(\u0026quot;{}!\u0026quot;, number); number = number - 1; } println!(\u0026quot;LIFTOFF!!!\u0026quot;); }  使用 for 遍历集合 fn main() { let a = [10, 20, 30, 40, 50]; for element in a.iter() { println!(\u0026quot;the value is: {}\u0026quot;, element); } }  ","id":27,"section":"posts","summary":"if 表达式 fn main() { let number = 3; if number \u0026lt; 5 { println!(\u0026quot;condition was true\u0026quot;); } else { println!(\u0026quot;condition was false\u0026quot;); } } 使用 else if 处理多重条件 let number = 6; if number % 4 == 0 { println!(\u0026quot;number is divisible by 4\u0026quot;); } else if number % 3 == 0 { println!(\u0026quot;number is divisible by 3\u0026quot;); } else if","tags":["Rust","Rust控制流程"],"title":"Rust之旅-控制流程","uri":"https://littleguest.github.io/posts/rust-tour-control-flow/","year":"2020"},{"content":"整型    长度 有符号 无符号     8-bit i8 u8   16-bit i16 u16   32-bit i32 u32   64-bit i64 u64   128-bit i128 u128   arch isize usize    浮点型 f32，f64\n布尔类型 bool\n字符类型 使用单引号指定\n元组类型 数组类型 元组长度固定，使用包含在圆括号中的逗号分隔的值列表来创建一个元组。元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的。\nuse std::fmt; use std::mem; #[derive(Debug)] struct Matrix(f32, f32, f32, f32); fn main(){ // 变量可以给出类型说明。 let logical: bool = true; let a_float: f64 = 1.0; // 常规说明 let an_integer = 5i32; // 后缀说明 // 否则会按默认方式决定类型。 let default_float = 3.0; // `f64` let default_integer = 7; // `i32` // 类型也可根据上下文自动推断。 let mut inferred_type = 12; // 根据下一行的赋值推断为 i64 类型 inferred_type = 4294967296i64; // 可变的（mutable）变量，其值可以改变。 let mut mutable = 12; // Mutable `i32` mutable = 21; // 报错！变量的类型并不能改变。 // mutable = true; // 但可以用掩蔽（shadow）来覆盖前面的变量。 let mutable = true; // 整数相加 println!(\u0026quot;1 + 2 = {}\u0026quot;, 1u32 + 2); // 整数相减 println!(\u0026quot;1 - 2 = {}\u0026quot;, 1i32 - 2); // 试一试 ^ 尝试将 `1i32` 改为 `1u32`，体会为什么类型声明这么重要 // 短路求值的布尔逻辑 println!(\u0026quot;true AND false is {}\u0026quot;, true \u0026amp;\u0026amp; false); println!(\u0026quot;true OR false is {}\u0026quot;, true || false); println!(\u0026quot;NOT true is {}\u0026quot;, !true); // 位运算 println!(\u0026quot;0011 AND 0101 is {:04b}\u0026quot;, 0b0011u32 \u0026amp; 0b0101); println!(\u0026quot;0011 OR 0101 is {:04b}\u0026quot;, 0b0011u32 | 0b0101); println!(\u0026quot;0011 XOR 0101 is {:04b}\u0026quot;, 0b0011u32 ^ 0b0101); println!(\u0026quot;1 \u0026lt;\u0026lt; 5 is {}\u0026quot;, 1u32 \u0026lt;\u0026lt; 5); println!(\u0026quot;0x80 \u0026gt;\u0026gt; 2 is 0x{:x}\u0026quot;, 0x80u32 \u0026gt;\u0026gt; 2); // 使用下划线改善数字的可读性！ println!(\u0026quot;One million is written as {}\u0026quot;, 1_000_000u32); // 包含各种不同类型的元组 let long_tuple = (1u8, 2u16, 3u32, 4u64,-1i8, -2i16, -3i32, -4i64,0.1f32, 0.2f64,'a', true); // 通过元组的下标来访问具体的值 println!(\u0026quot;long tuple first value: {}\u0026quot;, long_tuple.0); println!(\u0026quot;long tuple second value: {}\u0026quot;, long_tuple.1); // 元组也可以充当元组的元素 let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16); // 元组可以打印 println!(\u0026quot;tuple of tuples: {:?}\u0026quot;, tuple_of_tuples); // 但很长的元组无法打印 // let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13); // println!(\u0026quot;too long tuple: {:?}\u0026quot;, too_long_tuple); // 试一试 ^ 取消上面两行的注释，阅读编译器给出的错误信息。 let pair = (1, true); println!(\u0026quot;pair is {:?}\u0026quot;, pair); println!(\u0026quot;the reversed pair is {:?}\u0026quot;, reverse(pair)); // 创建单元素元组需要一个额外的逗号，这是为了和被括号包含的字面量作区分。 println!(\u0026quot;one element tuple: {:?}\u0026quot;, (5u32,)); println!(\u0026quot;just an integer: {:?}\u0026quot;, (5u32)); // 元组可以被解构（deconstruct），从而将值绑定给变量 let tuple = (1, \u0026quot;hello\u0026quot;, 4.5, true); let (a, b, c, d) = tuple; println!(\u0026quot;{:?}, {:?}, {:?}, {:?}\u0026quot;, a, b, c, d); let matrix = Matrix(1.1, 1.2, 2.1, 2.2); println!(\u0026quot;{:?}\u0026quot;, matrix); impl fmt::Display for Matrix{ fn fmt(\u0026amp;self,f: \u0026amp;mut fmt::Formatter)-\u0026gt;fmt::Result{ write!(f, \u0026quot;({} {})\\n({} {})\u0026quot;, self.0, self.1,self.2,self.3) } } println!(\u0026quot;{}\u0026quot;, matrix); println!(\u0026quot;{}\u0026quot;, transpose(matrix)); println!(\u0026quot;数组和切片\u0026quot;); // 定长数组（类型标记是多余的） let xs: [i32; 5] = [1, 2, 3, 4, 5]; // 所有元素可以初始化成相同的值 let ys: [i32; 500] = [0; 500]; // 下标从 0 开始 println!(\u0026quot;first element of the array: {}\u0026quot;, xs[0]); println!(\u0026quot;second element of the array: {}\u0026quot;, xs[1]); // `len` 返回数组的大小 println!(\u0026quot;array size: {}\u0026quot;, xs.len()); // 数组是在栈中分配的 println!(\u0026quot;array occupies {} bytes\u0026quot;, mem::size_of_val(\u0026amp;xs)); // 数组可以自动被借用成为 slice println!(\u0026quot;borrow the whole array as a slice\u0026quot;); analyze_slice(\u0026amp;xs); // slice 可以指向数组的一部分 println!(\u0026quot;borrow a section of the array as a slice\u0026quot;); analyze_slice(\u0026amp;ys[1 .. 4]); // 越界的下标会引发致命错误（panic） // println!(\u0026quot;{}\u0026quot;, xs[5]); } // 元组可以充当函数的参数和返回值 fn reverse(pair: (i32, bool)) -\u0026gt; (bool, i32) { // 可以使用 `let` 把一个元组的成员绑定到一些变量 let (integer, boolean) = pair; (boolean, integer) } fn transpose(matrix: Matrix)-\u0026gt;Matrix{ Matrix(matrix.0,matrix.2,matrix.1,matrix.3) } // 此函数借用一个 slice fn analyze_slice(slice: \u0026amp;[i32]) { println!(\u0026quot;first element of the slice: {}\u0026quot;, slice[0]); println!(\u0026quot;the slice has {} elements\u0026quot;, slice.len()); }  ","id":28,"section":"posts","summary":"整型 长度 有符号 无符号 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 arch isize usize 浮点型 f32，f64 布尔类型 bool 字符类型 使用单引号指定 元组类型 数组类型 元组长度固定，使","tags":["Rust","Rust数据类型"],"title":"Rust之旅-数据类型","uri":"https://littleguest.github.io/posts/rust-tour-data-types/","year":"2020"},{"content":"变量 声明变量使用 let 关键字，变量是默认不可变的；\n可变变量 在变量前加mut关键字，使其可变；\n常量 声明常量使用const关键字，并且必须指定类型，常量不能使用mut（Rust 常量的命名规范是使用下划线分隔的大写字母单词，并且可以在数字字面值中插入下划线来提升可读性）；\nShadowing const MAX_SIZE: i32 = 10; fn main() { let an_integer = 1u32; let a_boolean = true; let unit = (); // 将 `an_integer` 复制到 `copied_integer` let copied_integer = an_integer; println!(\u0026quot;An integer: {:?}\u0026quot;, copied_integer); println!(\u0026quot;A boolean: {:?}\u0026quot;, a_boolean); println!(\u0026quot;Meet the unit value: {:?}\u0026quot;, unit); // 编译器会对未使用的变量绑定产生警告；可以给变量名加上下划线前缀来消除警告。 let _unused_variable = 3u32; let _noisy_unused_variable = 2u32; // 改正 ^ 在变量名前加上下划线以消除警告 println!(\u0026quot;=== 可变变量 ===\u0026quot;); // 变量绑定默认是不可变的（immutable），但加上 mut 修饰语后变量就可以改变。 let _immutable_binding = 1; let mut mutable_binding = 1; println!(\u0026quot;Before mutation: {}\u0026quot;, mutable_binding); // 正确代码 mutable_binding += 1; println!(\u0026quot;After mutation: {}\u0026quot;, mutable_binding); // 错误！ // _immutable_binding += 1; // 改正 ^ 将此行注释掉 println!(\u0026quot;=== scope and shadowing ===\u0026quot;); // 此绑定生存于 main 函数中 let long_lived_binding = 1; // 这是一个代码块，比 main 函数拥有更小的作用域 { // 此绑定只存在于本代码块 let short_lived_binding = 2; println!(\u0026quot;inner short: {}\u0026quot;, short_lived_binding); // 此绑定*掩蔽*了外面的绑定 let long_lived_binding = 5_f32; println!(\u0026quot;inner long: {}\u0026quot;, long_lived_binding); } // 代码块结束 // 报错！`short_lived_binding` 在此作用域上不存在 // println!(\u0026quot;outer short: {}\u0026quot;, short_lived_binding); // 改正 ^ 注释掉这行 println!(\u0026quot;outer long: {}\u0026quot;, long_lived_binding); // 此绑定同样*掩蔽*了前面的绑定 let long_lived_binding = 'a'; println!(\u0026quot;outer long: {}\u0026quot;, long_lived_binding); println!(\u0026quot;declate before\u0026quot;); // 声明一个变量绑定 let a_binding; { let x = 2; // 初始化一个绑定 a_binding = x * x; } println!(\u0026quot;a binding: {}\u0026quot;, a_binding); let another_binding; // 报错！使用了未初始化的绑定 // println!(\u0026quot;another binding: {}\u0026quot;, another_binding); // 改正 ^ 注释掉此行 another_binding = 1; println!(\u0026quot;another binding: {}\u0026quot;, another_binding); }  ","id":29,"section":"posts","summary":"变量 声明变量使用 let 关键字，变量是默认不可变的； 可变变量 在变量前加mut关键字，使其可变； 常量 声明常量使用const关键字，并且必须指定类型，","tags":["Rust","Rust变量"],"title":"Rust之旅-变量和可变性","uri":"https://littleguest.github.io/posts/rust-tour-variable/","year":"2020"},{"content":"运算符    运算符 示例 解释 是否可重载     ! ident!(...), ident!{...}, ident![...] 宏展开    ! !expr 按位非或逻辑非 Not   != var != expr 不等比较 PartialEq   % expr % expr 算术取模 Rem   %= var %= expr 算术取模与赋值 RemAssign   \u0026amp; \u0026amp;expr, \u0026amp;mut expr 借用    \u0026amp; \u0026amp;type, \u0026amp;mut type, \u0026amp;'a type, \u0026amp;'a mut type 借用指针类型    \u0026amp; expr \u0026amp; expr 按位与 BitAnd   \u0026amp;= var \u0026amp;= expr 按位与及赋值 BitAndAssign   \u0026amp;\u0026amp; expr \u0026amp;\u0026amp; expr 逻辑与    * expr * expr 算术乘法 Mul   *= var *= expr 算术乘法与赋值 MulAssign   * *expr 解引用    * *const type, *mut type 裸指针    + trait + trait, 'a + trait 复合类型限制    + expr + expr 算术加法 Add   += var += expr 算术加法与赋值 AddAssign   , expr, expr 参数以及元素分隔符    - - expr 算术取负 Neg   - expr - expr 算术减法 Sub   -= var -= expr 算术减法与赋值 SubAssign   -\u0026gt; fn(...) -\u0026gt; type, ` \u0026hellip; -\u0026gt; type`   . expr.ident 成员访问    .. .., expr.., ..expr, expr..expr 右排除范围    .. ..expr 结构体更新语法    .. variant(x, ..), struct_type { x, .. } “与剩余部分”的模式绑定    ... expr...expr 模式: 范围包含模式    / expr / expr 算术除法 Div   /= var /= expr 算术除法与赋值 DivAssign   : pat: type, ident: type 约束    : ident: expr 结构体字段初始化    : 'a: loop {...} 循环标志    ; expr; 语句和语句结束符    ; [...; len] 固定大小数组语法的部分    \u0026lt;\u0026lt; expr \u0026lt;\u0026lt; expr 左移 Shl   \u0026lt;\u0026lt;= var \u0026lt;\u0026lt;= expr 左移与赋值 ShlAssign   \u0026lt; expr \u0026lt; expr 小于比较 PartialOrd   \u0026lt;= expr \u0026lt;= expr 小于等于比较 PartialOrd   = var = expr, ident = type 赋值/等值    == expr == expr 等于比较 PartialEq   =\u0026gt; pat =\u0026gt; expr 匹配准备语法的部分    \u0026gt; expr \u0026gt; expr 大于比较 PartialOrd   \u0026gt;= expr \u0026gt;= expr 大于等于比较 PartialOrd   \u0026gt;\u0026gt; expr \u0026gt;\u0026gt; expr 右移 Shr   \u0026gt;\u0026gt;= var \u0026gt;\u0026gt;= expr 右移与赋值 ShrAssign   @ ident @ pat 模式绑定    ^ expr ^ expr 按位异或 BitXor   ^= var ^= expr 按位异或与赋值 BitXorAssign   ` ` `pat pat`   ` ` `expr expr`   ` =` `var = expr`   `  ` `expr   ? expr? 错误传播     非运算符符号    符号 解释     'ident 命名生命周期或循环标签   ...u8, ...i32, ...f64, ...usize, 等 指定类型的数值常量   \u0026quot;...\u0026quot; 字符串常量   r\u0026quot;...\u0026quot;, r#\u0026quot;...\u0026quot;#, r##\u0026quot;...\u0026quot;##, etc. 原始字符串字面值, 未处理的转义字符   b\u0026quot;...\u0026quot; 字节字符串字面值; 构造一个 [u8] 类型而非字符串   br\u0026quot;...\u0026quot;, br#\u0026quot;...\u0026quot;#, br##\u0026quot;...\u0026quot;##, 等 原始字节字符串字面值，原始和字节字符串字面值的结合   '...' 字符字面值   b'...' ASCII 码字节字面值   ` \u0026hellip;   ! 离散函数的总是为空的类型   _ “忽略” 模式绑定；也用于增强整型字面值的可读性    路径相关语法\n   符号 解释     ident::ident 命名空间路径   ::path 与 crate 根相对的路径（如一个显式绝对路径）   self::path 与当前模块相对的路径（如一个显式相对路径）   super::path 与父模块相对的路径   type::ident, ::ident 关联常量、函数以及类型   ::... 不可以被直接命名的关联项类型（如 \u0026lt;\u0026amp;T\u0026gt;::...，\u0026lt;[T]\u0026gt;::...， 等）   trait::method(...) 通过命名定义的 trait 来消除方法调用的二义性   type::method(...) 通过命名定义的类型来消除方法调用的二义性   ::method(...) 通过命名 trait 和类型来消除方法调用的二义性    泛型\n   符号 解释     path\u0026lt;...\u0026gt; 为一个类型中的泛型指定具体参数（如 Vec）   path::\u0026lt;...\u0026gt;, method::\u0026lt;...\u0026gt; 为一个泛型、函数或表达式中的方法指定具体参数，通常指 turbofish（如 \u0026quot;42\u0026quot;.parse::()）   fn ident\u0026lt;...\u0026gt; ... 泛型函数定义   struct ident\u0026lt;...\u0026gt; ... 泛型结构体定义   enum ident\u0026lt;...\u0026gt; ... 泛型枚举定义   impl\u0026lt;...\u0026gt; ... 定义泛型实现   for\u0026lt;...\u0026gt; type 高级生命周期限制   type 泛型，其一个或多个相关类型必须被指定为特定类型（如 Iterator）    Trait Bound 约束\n   符号 解释     T: U 泛型参数 T 约束于实现了 U 的类型   T: 'a 泛型 T 的生命周期必须长于 'a（意味着该类型不能传递包含生命周期短于 'a 的任何引用）   T : 'static 泛型 T 不包含除 \u0026lsquo;static 之外的借用引用   'b: 'a 泛型 'b 生命周期必须长于泛型 'a   T: ?Sized 使用一个不定大小的泛型类型   'a + trait, trait + trait 复合类型限制    宏与属性\n   符号 解释     #[meta] 外部属性   #![meta] 内部属性   $ident 宏替换   $ident:kind 宏捕获   $(…)… 宏重复    注释\n   符号 注释     // 行注释   //! 内部行文档注释   /// 外部行文档注释   /*...*/ 块注释   /*!...*/ 内部块文档注释   /**...*/ 外部块文档注释    元组\n   符号 解释     () 空元组（亦称单元），即是字面值也是类型   (expr) 括号表达式   (expr,) 单一元素元组表达式   (type,) 单一元素元组类型   (expr, ...) 元组表达式   (type, ...) 元组类型   expr(expr, ...) 函数调用表达式；也用于初始化元组结构体 struct 以及元组枚举 enum 变体   ident!(...), ident!{...}, ident![...] 宏调用   expr.0, expr.1, etc. 元组索引    大括号\n   符号 解释     {...} 块表达式   Type {...} struct 字面值    方括号\n   符号 解释     [...] 数组   [expr; len] 复制了 len个 expr的数组   [type; len] 包含 len个 type 类型的数组   expr[expr] 集合索引。 重载（Index, IndexMut）   expr[..], expr[a..], expr[..b], expr[a..b] 集合索引，使用 Range，RangeFrom，RangeTo 或 RangeFull 作为索引来代替集合 slice    ","id":30,"section":"posts","summary":"运算符 运算符 示例 解释 是否可重载 ! ident!(...), ident!{...}, ident![...] 宏展开 ! !expr 按位非或逻辑非 Not != var != expr 不等比较 PartialEq % expr % expr 算术取模 Rem %= var %= expr 算术取模与赋值 RemAssign \u0026amp; \u0026amp;expr, \u0026amp;mut expr 借用 \u0026amp; \u0026amp;type,","tags":["Rust","Rust运算符与符号"],"title":"Rust之旅-运算符与符号","uri":"https://littleguest.github.io/posts/rust-tour-operators-symbols/","year":"2020"},{"content":"Rust 关键字 正在使用的关键字    关键字 描述     as 强制类型转换，消除特定包含项的 trait 的歧义，或者对 use 和 extern crate 语句中的项重命名   async 返回一个 Future 而不是阻塞当前线程   await suspend execution until the result of a Future is ready   break 立刻退出循环   const 定义常量或不变裸指针（constant raw pointer）   continue 继续进入下一次循环迭代   crate 链接（link）一个外部 crate 或一个代表宏定义的 crate 的宏变量   dyn 动态分发 trait 对象   else 作为 if 和 if let 控制流结构的 fallback   enum 定义一个枚举   extern 链接一个外部 crate 、函数或变量   false 布尔字面值 false   fn 定义一个函数或 函数指针类型 (function pointer type)   for 遍历一个迭代器或实现一个 trait 或者指定一个更高级的生命周期   if 基于条件表达式的结果分支   impl 实现自有或 trait 功能   in for 循环语法的一部分   let 绑定一个变量   loop 无条件循环   match 模式匹配   mod 定义一个模块   move 使闭包获取其所捕获项的所有权   mut 表示引用、裸指针或模式绑定的可变性   pub 表示结构体字段、impl 块或模块的公有可见性   ref 通过引用绑定   return 从函数中返回   Self 实现 trait 的类型的类型别名   self 表示方法本身或当前模块   static 表示全局变量或在整个程序执行期间保持其生命周期   struct 定义一个结构体   super 表示当前模块的父模块   trait 定义一个 trait   true 布尔字面值 true   type 定义一个类型别名或关联类型   union define a union and is only a keyword when used in a union declaration   unsafe 表示不安全的代码、函数、trait 或实现   use 引入外部空间的符号   where 表示一个约束类型的从句   while 基于一个表达式的结果判断是否进行循环    保留做将来使用的关键字  abstract become box do final macro override priv try typeof unsized virtual yield  以上关键字不能被用作标识符（除了“原始标识符”），这包括函数、变量、参数、结构体字段、模块、crate、常量、宏、静态值、属性、类型、trait 或生命周期 的名字。\n原始标识符 原始标识符（Raw identifiers）允许你使用通常不能使用的关键字，其带有 r# 前缀。\n","id":31,"section":"posts","summary":"Rust 关键字 正在使用的关键字 关键字 描述 as 强制类型转换，消除特定包含项的 trait 的歧义，或者对 use 和 extern crate 语句中的项重命名 async 返回一个 Future 而不是阻塞当前线程 await suspend","tags":["Rust","Rust关键字"],"title":"Rust之旅-关键字","uri":"https://littleguest.github.io/posts/rust-tour-keywords/","year":"2020"},{"content":"Rust 之旅 今天开始 Rust 的旅程。^_^\n安装 Rust\n我的系统是 deepin20，直接根据官网安装教程走就行了，使用 Rustup 安装\n curl \u0026ndash;proto \u0026lsquo;=https\u0026rsquo; \u0026ndash;tlsv1.2 -sSf https://sh.rustup.rs | sh\n 查看 Rust 版本\n rustc -V\n rustc 1.45.2 (d3fb005a3 2020-07-31)  更新 Rust\n rustup update\n ","id":32,"section":"posts","summary":"Rust 之旅 今天开始 Rust 的旅程。^_^ 安装 Rust 我的系统是 deepin20，直接根据官网安装教程走就行了，使用 Rustup 安装 curl \u0026ndash;proto \u0026lsquo;=https\u0026rsquo; \u0026ndash;tlsv1.2 -sSf https://sh.rustup.rs | sh 查看 Rust 版本 rustc -V rustc 1.45.2 (d3fb005a3","tags":["Rust"],"title":"Rust之旅-从放弃到放弃","uri":"https://littleguest.github.io/posts/rust-tour-give-up/","year":"2020"}],"tags":[{"title":"AppImage","uri":"https://littleguest.github.io/tags/appimage/"},{"title":"Cargo","uri":"https://littleguest.github.io/tags/cargo/"},{"title":"Docker","uri":"https://littleguest.github.io/tags/docker/"},{"title":"Git","uri":"https://littleguest.github.io/tags/git/"},{"title":"Java","uri":"https://littleguest.github.io/tags/java/"},{"title":"Linux","uri":"https://littleguest.github.io/tags/linux/"},{"title":"Lombok","uri":"https://littleguest.github.io/tags/lombok/"},{"title":"max7219","uri":"https://littleguest.github.io/tags/max7219/"},{"title":"MySQL","uri":"https://littleguest.github.io/tags/mysql/"},{"title":"MySQL主从","uri":"https://littleguest.github.io/tags/mysql%E4%B8%BB%E4%BB%8E/"},{"title":"Rust","uri":"https://littleguest.github.io/tags/rust/"},{"title":"Rust关键字","uri":"https://littleguest.github.io/tags/rust%E5%85%B3%E9%94%AE%E5%AD%97/"},{"title":"Rust变量","uri":"https://littleguest.github.io/tags/rust%E5%8F%98%E9%87%8F/"},{"title":"Rust嵌入式","uri":"https://littleguest.github.io/tags/rust%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"title":"Rust控制流程","uri":"https://littleguest.github.io/tags/rust%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/"},{"title":"Rust数据类型","uri":"https://littleguest.github.io/tags/rust%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"Rust杂记","uri":"https://littleguest.github.io/tags/rust%E6%9D%82%E8%AE%B0/"},{"title":"Rust泛型","uri":"https://littleguest.github.io/tags/rust%E6%B3%9B%E5%9E%8B/"},{"title":"Rust生命周期","uri":"https://littleguest.github.io/tags/rust%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"title":"Rust运算符与符号","uri":"https://littleguest.github.io/tags/rust%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E7%AC%A6%E5%8F%B7/"},{"title":"Rust迭代器","uri":"https://littleguest.github.io/tags/rust%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"title":"Rust错误处理","uri":"https://littleguest.github.io/tags/rust%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"},{"title":"Stream","uri":"https://littleguest.github.io/tags/stream/"},{"title":"Vim","uri":"https://littleguest.github.io/tags/vim/"},{"title":"交叉编译","uri":"https://littleguest.github.io/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"},{"title":"位运算","uri":"https://littleguest.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"title":"开源协议","uri":"https://littleguest.github.io/tags/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/"},{"title":"树莓派","uri":"https://littleguest.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"树莓派-RGBLED","uri":"https://littleguest.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE-rgbled/"},{"title":"测试","uri":"https://littleguest.github.io/tags/%E6%B5%8B%E8%AF%95/"},{"title":"游戏","uri":"https://littleguest.github.io/tags/%E6%B8%B8%E6%88%8F/"},{"title":"算法","uri":"https://littleguest.github.io/tags/%E7%AE%97%E6%B3%95/"},{"title":"调试Rust","uri":"https://littleguest.github.io/tags/%E8%B0%83%E8%AF%95rust/"},{"title":"配置文件格式转换","uri":"https://littleguest.github.io/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"}]}